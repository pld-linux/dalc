diff -Nru dalc-0.1/AUTHORS dalc-0.1.new/AUTHORS
--- dalc-0.1/AUTHORS	Thu Jan  1 01:00:00 1970
+++ dalc-0.1.new/AUTHORS	Fri Nov 24 16:46:10 2000
@@ -0,0 +1 @@
+ 
\ No newline at end of file
diff -Nru dalc-0.1/ChangeLog dalc-0.1.new/ChangeLog
--- dalc-0.1/ChangeLog	Thu Jan  1 01:00:00 1970
+++ dalc-0.1.new/ChangeLog	Fri Nov 24 16:46:08 2000
@@ -0,0 +1 @@
+ 
\ No newline at end of file
diff -Nru dalc-0.1/INSTALL dalc-0.1.new/INSTALL
--- dalc-0.1/INSTALL	Thu Jan  1 01:00:00 1970
+++ dalc-0.1.new/INSTALL	Fri Nov 24 16:46:12 2000
@@ -0,0 +1 @@
+ 
\ No newline at end of file
diff -Nru dalc-0.1/Makefile dalc-0.1.new/Makefile
--- dalc-0.1/Makefile	Thu Dec  9 06:17:36 1999
+++ dalc-0.1.new/Makefile	Thu Jan  1 01:00:00 1970
@@ -1,27 +0,0 @@
-CPP		=g++
-MANFILES	=dalc.1
-MANDIR		=/usr/local/man/man1
-BINARIES	=dalc
-BINDIR		=/usr/local/bin
-CFLAGS		=-O3 -Wall -m486 -DVIEWER=\"xv\" -DCONVERTER=\"ppmtogif\"
-LDFLAGS		=-L/usr/X11R6/lib
-LIBS		=-lm -lncurses -lmenu
-INSTALL		=install -o root -g root
-
-.SUFFIXES:	.C
-
-.C.o:
-		g++ $(CFLAGS) -o $*.o -c $*.C
-
-all:		$(BINARIES)
-
-dalc:		dalc.o dalexpr.o
-		g++ $(LIBS) $(LDFLAGS) -o $@ $^
-
-install:
-		$(INSTALL) -m 0755 $(BINARIES) $(BINDIR)
-		$(INSTALL) -m 0644 $(MANFILES) $(MANDIR)
-
-clean:		
-		rm -f *.o
-		rm -f $(BINARIES)
diff -Nru dalc-0.1/Makefile.am dalc-0.1.new/Makefile.am
--- dalc-0.1/Makefile.am	Thu Jan  1 01:00:00 1970
+++ dalc-0.1.new/Makefile.am	Fri Nov 24 16:38:02 2000
@@ -0,0 +1,9 @@
+
+INCLUDES = $(CURSES_INCLUDEDIR) \
+	-DVIEWER=\"xv\" -DCONVERTER=\"ppmtogif\"
+
+bin_PROGRAMS = dalc
+
+dalc_SOURCES = dalc.cc dalexpr.cc dalexpr.h
+
+man_MANS = dalc.1
diff -Nru dalc-0.1/NEWS dalc-0.1.new/NEWS
--- dalc-0.1/NEWS	Thu Jan  1 01:00:00 1970
+++ dalc-0.1.new/NEWS	Fri Nov 24 16:46:00 2000
@@ -0,0 +1 @@
+ 
\ No newline at end of file
diff -Nru dalc-0.1/README dalc-0.1.new/README
--- dalc-0.1/README	Thu Jan  1 01:00:00 1970
+++ dalc-0.1.new/README	Fri Nov 24 16:45:52 2000
@@ -0,0 +1 @@
+ 
\ No newline at end of file
diff -Nru dalc-0.1/acconfig.h dalc-0.1.new/acconfig.h
--- dalc-0.1/acconfig.h	Thu Jan  1 01:00:00 1970
+++ dalc-0.1.new/acconfig.h	Fri Nov 24 16:32:42 2000
@@ -0,0 +1,29 @@
+/* Define if you want to turn on SCO-specific code */
+#undef SCO_FLAVOR
+
+/* Found some version of curses that we're going to use */
+#undef HAS_CURSES
+
+/* Are you using other type of curses? */
+#undef OTHER_CURSES
+
+/* Use SunOS SysV curses? */
+#undef USE_SUNOS_CURSES
+
+/* Use old BSD curses? */
+#undef USE_BSD_CURSES
+
+/* Use SystemV curses? */
+#undef USE_SYSV_CURSES
+
+/* Use Ncurses? */
+#undef USE_NCURSES
+
+/* If you Curses does not have color define this one */
+#undef NO_COLOR_CURSES
+
+/* If Slang library should use termcap */
+#undef USE_TERMCAP
+
+/* Version of ncurses */
+#undef NCURSES_970530
diff -Nru dalc-0.1/acinclude.m4 dalc-0.1.new/acinclude.m4
--- dalc-0.1/acinclude.m4	Thu Jan  1 01:00:00 1970
+++ dalc-0.1.new/acinclude.m4	Thu Aug  3 00:26:45 2000
@@ -0,0 +1,318 @@
+dnl Curses detection: Munged from Midnight Commander's configure.in
+dnl
+dnl What it does:
+dnl =============
+dnl
+dnl - Determine which version of curses is installed on your system
+dnl   and set the -I/-L/-l compiler entries and add a few preprocessor
+dnl   symbols 
+dnl - Do an AC_SUBST on the CURSES_INCLUDEDIR and CURSES_LIBS so that
+dnl   @CURSES_INCLUDEDIR@ and @CURSES_LIBS@ will be available in
+dnl   Makefile.in's
+dnl - Modify the following configure variables (these are the only
+dnl   curses.m4 variables you can access from within configure.in)
+dnl   CURSES_INCLUDEDIR - contains -I's and possibly -DRENAMED_CURSES if
+dnl                       an ncurses.h that's been renamed to curses.h
+dnl                       is found.
+dnl   CURSES_LIBS       - sets -L and -l's appropriately
+dnl   CFLAGS            - if --with-sco, add -D_SVID3 
+dnl   has_curses        - exports result of tests to rest of configure
+dnl
+dnl Usage:
+dnl ======
+dnl 1) Add lines indicated below to acconfig.h
+dnl 2) call AC_CHECK_CURSES after AC_PROG_CC in your configure.in
+dnl 3) Instead of #include <curses.h> you should use the following to
+dnl    properly locate ncurses or curses header file
+dnl
+dnl    #if defined(USE_NCURSES) && !defined(RENAMED_NCURSES)
+dnl    #include <ncurses.h>
+dnl    #else
+dnl    #include <curses.h>
+dnl    #endif
+dnl
+dnl 4) Make sure to add @CURSES_INCLUDEDIR@ to your preprocessor flags
+dnl 5) Make sure to add @CURSES_LIBS@ to your linker flags or LIBS
+dnl
+dnl Notes with automake:
+dnl - call AM_CONDITIONAL(HAS_CURSES, test "$has_curses" = true) from
+dnl   configure.in
+dnl - your Makefile.am can look something like this
+dnl   -----------------------------------------------
+dnl   INCLUDES= blah blah blah $(CURSES_INCLUDEDIR) 
+dnl   if HAS_CURSES
+dnl   CURSES_TARGETS=name_of_curses_prog
+dnl   endif
+dnl   bin_PROGRAMS = other_programs $(CURSES_TARGETS)
+dnl   other_programs_SOURCES = blah blah blah
+dnl   name_of_curses_prog_SOURCES = blah blah blah
+dnl   other_programs_LDADD = blah
+dnl   name_of_curses_prog_LDADD = blah $(CURSES_LIBS)
+dnl   -----------------------------------------------
+dnl
+dnl
+dnl The following lines should be added to acconfig.h:
+dnl ==================================================
+dnl
+dnl /*=== Curses version detection defines ===*/
+dnl /* Found some version of curses that we're going to use */
+dnl #undef HAS_CURSES
+dnl    
+dnl /* Use SunOS SysV curses? */
+dnl #undef USE_SUNOS_CURSES
+dnl 
+dnl /* Use old BSD curses - not used right now */
+dnl #undef USE_BSD_CURSES
+dnl 
+dnl /* Use SystemV curses? */
+dnl #undef USE_SYSV_CURSES
+dnl 
+dnl /* Use Ncurses? */
+dnl #undef USE_NCURSES
+dnl 
+dnl /* If you Curses does not have color define this one */
+dnl #undef NO_COLOR_CURSES
+dnl 
+dnl /* Define if you want to turn on SCO-specific code */
+dnl #undef SCO_FLAVOR
+dnl 
+dnl /* Set to reflect version of ncurses *
+dnl  *   0 = version 1.*
+dnl  *   1 = version 1.9.9g
+dnl  *   2 = version 4.0/4.1 */
+dnl #undef NCURSES_970530
+dnl
+dnl /*=== End new stuff for acconfig.h ===*/
+dnl 
+
+
+AC_DEFUN(AC_CHECK_CURSES,[
+	search_ncurses=true
+	screen_manager=""
+	has_curses=false
+
+	CFLAGS=${CFLAGS--O}
+
+	AC_SUBST(CURSES_LIBS)
+	AC_SUBST(CURSES_INCLUDEDIR)
+
+	AC_ARG_WITH(sco,
+	  [  --with-sco              Use this to turn on SCO-specific code],[
+	  if test x$withval = xyes; then
+		AC_DEFINE(SCO_FLAVOR)
+		CFLAGS="$CFLAGS -D_SVID3"
+	  fi
+	])
+
+	AC_ARG_WITH(sunos-curses,
+	  [  --with-sunos-curses     Used to force SunOS 4.x curses],[
+	  if test x$withval = xyes; then
+		AC_USE_SUNOS_CURSES
+	  fi
+	])
+
+	AC_ARG_WITH(osf1-curses,
+	  [  --with-osf1-curses      Used to force OSF/1 curses],[
+	  if test x$withval = xyes; then
+		AC_USE_OSF1_CURSES
+	  fi
+	])
+
+	AC_ARG_WITH(vcurses,
+	  [  --with-vcurses[=incdir] Used to force SysV curses],
+	  if test x$withval != xyes; then
+		CURSES_INCLUDEDIR="-I$withval"
+	  fi
+	  AC_USE_SYSV_CURSES
+	)
+
+	AC_ARG_WITH(ncurses,
+	  [  --with-ncurses[=dir]  Compile with ncurses/locate base dir],
+	  if test x$withval = xno ; then
+		search_ncurses=false
+	  elif test x$withval != xyes ; then
+		CURSES_LIBS="$LIBS -L$withval/lib -lncurses"
+		CURSES_INCLUDEDIR="-I$withval/include"
+		search_ncurses=false
+		screen_manager="ncurses"
+		AC_DEFINE(USE_NCURSES)
+		AC_DEFINE(HAS_CURSES)
+		has_curses=true
+	  fi
+	)
+
+	if $search_ncurses
+	then
+		AC_SEARCH_NCURSES()
+	fi
+
+
+])
+
+
+AC_DEFUN(AC_USE_SUNOS_CURSES, [
+	search_ncurses=false
+	screen_manager="SunOS 4.x /usr/5include curses"
+	AC_MSG_RESULT(Using SunOS 4.x /usr/5include curses)
+	AC_DEFINE(USE_SUNOS_CURSES)
+	AC_DEFINE(HAS_CURSES)
+	has_curses=true
+	AC_DEFINE(NO_COLOR_CURSES)
+	AC_DEFINE(USE_SYSV_CURSES)
+	CURSES_INCLUDEDIR="-I/usr/5include"
+	CURSES_LIBS="/usr/5lib/libcurses.a /usr/5lib/libtermcap.a"
+	AC_MSG_RESULT(Please note that some screen refreshs may fail)
+])
+
+AC_DEFUN(AC_USE_OSF1_CURSES, [
+       AC_MSG_RESULT(Using OSF1 curses)
+       search_ncurses=false
+       screen_manager="OSF1 curses"
+       AC_DEFINE(HAS_CURSES)
+       has_curses=true
+       AC_DEFINE(NO_COLOR_CURSES)
+       AC_DEFINE(USE_SYSV_CURSES)
+       CURSES_LIBS="-lcurses"
+])
+
+AC_DEFUN(AC_USE_SYSV_CURSES, [
+	AC_MSG_RESULT(Using SysV curses)
+	AC_DEFINE(HAS_CURSES)
+	has_curses=true
+	AC_DEFINE(USE_SYSV_CURSES)
+	search_ncurses=false
+	screen_manager="SysV/curses"
+	CURSES_LIBS="-lcurses"
+])
+
+dnl AC_ARG_WITH(bsd-curses,
+dnl [--with-bsd-curses         Used to compile with bsd curses, not very fancy],
+dnl 	search_ncurses=false
+dnl	screen_manager="Ultrix/cursesX"
+dnl	if test $system = ULTRIX
+dnl	then
+dnl	    THIS_CURSES=cursesX
+dnl        else
+dnl	    THIS_CURSES=curses
+dnl	fi
+dnl
+dnl	CURSES_LIBS="-l$THIS_CURSES -ltermcap"
+dnl	AC_DEFINE(HAS_CURSES)
+dnl	has_curses=true
+dnl	AC_DEFINE(USE_BSD_CURSES)
+dnl	AC_MSG_RESULT(Please note that some screen refreshs may fail)
+dnl	AC_MSG_WARN(Use of the bsdcurses extension has some)
+dnl	AC_MSG_WARN(display/input problems.)
+dnl	AC_MSG_WARN(Reconsider using xcurses)
+dnl)
+
+	
+dnl
+dnl Parameters: directory filename cureses_LIBS curses_INCLUDEDIR nicename
+dnl
+AC_DEFUN(AC_NCURSES, [
+    if $search_ncurses
+    then
+        if test -f $1/$2
+	then
+	    AC_MSG_RESULT(Found ncurses on $1/$2)
+ 	    CURSES_LIBS="$3"
+	    CURSES_INCLUDEDIR="$4"
+	    search_ncurses=false
+	    screen_manager=$5
+            AC_DEFINE(HAS_CURSES)
+            has_curses=true
+	    AC_DEFINE(USE_NCURSES)
+	fi
+    fi
+])
+
+AC_DEFUN(AC_SEARCH_NCURSES, [
+    AC_CHECKING("location of ncurses.h file")
+
+    AC_NCURSES(/usr/include, ncurses.h, -lncurses,, "ncurses on /usr/include")
+    AC_NCURSES(/usr/include/ncurses, ncurses.h, -lncurses, -I/usr/include/ncurses, "ncurses on /usr/include/ncurses")
+    AC_NCURSES(/usr/local/include, ncurses.h, -L/usr/local/lib -lncurses, -I/usr/local/include, "ncurses on /usr/local")
+    AC_NCURSES(/usr/local/include/ncurses, ncurses.h, -L/usr/local/lib -L/usr/local/lib/ncurses -lncurses, -I/usr/local/include/ncurses, "ncurses on /usr/local/include/ncurses")
+
+    AC_NCURSES(/usr/local/include/ncurses, curses.h, -L/usr/local/lib -lncurses, -I/usr/local/include/ncurses -DRENAMED_NCURSES, "renamed ncurses on /usr/local/.../ncurses")
+
+    AC_NCURSES(/usr/include/ncurses, curses.h, -lncurses, -I/usr/include/ncurses -DRENAMED_NCURSES, "renamed ncurses on /usr/include/ncurses")
+
+    dnl
+    dnl We couldn't find ncurses, try SysV curses
+    dnl
+    if $search_ncurses 
+    then
+        AC_EGREP_HEADER(init_color, /usr/include/curses.h,
+	    AC_USE_SYSV_CURSES)
+	AC_EGREP_CPP(USE_NCURSES,[
+#include <curses.h>
+#ifdef __NCURSES_H
+#undef USE_NCURSES
+USE_NCURSES
+#endif
+],[
+	CURSES_INCLUDEDIR="$CURSES_INCLUDEDIR -DRENAMED_NCURSES"
+        AC_DEFINE(HAS_CURSES)
+	has_curses=true
+        AC_DEFINE(USE_NCURSES)
+        search_ncurses=false
+        screen_manager="ncurses installed as curses"
+])
+    fi
+
+    dnl
+    dnl Try SunOS 4.x /usr/5{lib,include} ncurses
+    dnl The flags USE_SUNOS_CURSES, USE_BSD_CURSES and BUGGY_CURSES
+    dnl should be replaced by a more fine grained selection routine
+    dnl
+    if $search_ncurses
+    then
+	if test -f /usr/5include/curses.h
+	then
+	    AC_USE_SUNOS_CURSES
+        fi
+    else
+        # check for ncurses version, to properly ifdef mouse-fix
+	AC_MSG_CHECKING(for ncurses version)
+	ncurses_version=unknown
+cat > conftest.$ac_ext <<EOF
+[#]line __oline__ "configure"
+#include "confdefs.h"
+#ifdef RENAMED_NCURSES
+#include <curses.h>
+#else
+#include <ncurses.h>
+#endif
+#undef VERSION
+VERSION:NCURSES_VERSION
+EOF
+        if (eval "$ac_cpp conftest.$ac_ext") 2>&AC_FD_CC |
+  egrep "VERSION:" >conftest.out 2>&1; then
+changequote(,)dnl
+            ncurses_version=`cat conftest.out|sed -e 's/^[^"]*"//' -e 's/".*//'`
+changequote([,])dnl
+	fi
+	rm -rf conftest*
+        AC_MSG_RESULT($ncurses_version)
+	case "$ncurses_version" in
+changequote(,)dnl
+	4.[01])
+changequote([,])dnl
+            AC_DEFINE(NCURSES_970530,2)
+            ;;
+	1.9.9g)
+            AC_DEFINE(NCURSES_970530,1)
+            ;;
+	1*)
+            AC_DEFINE(NCURSES_970530,0)
+            ;;
+	esac
+    fi
+])
+
+
+
+
+
diff -Nru dalc-0.1/aclocal.m4 dalc-0.1.new/aclocal.m4
--- dalc-0.1/aclocal.m4	Thu Jan  1 01:00:00 1970
+++ dalc-0.1.new/aclocal.m4	Fri Nov 24 16:35:53 2000
@@ -0,0 +1,879 @@
+dnl aclocal.m4 generated automatically by aclocal 1.4a
+
+dnl Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl This program is distributed in the hope that it will be useful,
+dnl but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+dnl even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+dnl PARTICULAR PURPOSE.
+
+dnl Curses detection: Munged from Midnight Commander's configure.in
+dnl
+dnl What it does:
+dnl =============
+dnl
+dnl - Determine which version of curses is installed on your system
+dnl   and set the -I/-L/-l compiler entries and add a few preprocessor
+dnl   symbols 
+dnl - Do an AC_SUBST on the CURSES_INCLUDEDIR and CURSES_LIBS so that
+dnl   @CURSES_INCLUDEDIR@ and @CURSES_LIBS@ will be available in
+dnl   Makefile.in's
+dnl - Modify the following configure variables (these are the only
+dnl   curses.m4 variables you can access from within configure.in)
+dnl   CURSES_INCLUDEDIR - contains -I's and possibly -DRENAMED_CURSES if
+dnl                       an ncurses.h that's been renamed to curses.h
+dnl                       is found.
+dnl   CURSES_LIBS       - sets -L and -l's appropriately
+dnl   CFLAGS            - if --with-sco, add -D_SVID3 
+dnl   has_curses        - exports result of tests to rest of configure
+dnl
+dnl Usage:
+dnl ======
+dnl 1) Add lines indicated below to acconfig.h
+dnl 2) call AC_CHECK_CURSES after AC_PROG_CC in your configure.in
+dnl 3) Instead of #include <curses.h> you should use the following to
+dnl    properly locate ncurses or curses header file
+dnl
+dnl    #if defined(USE_NCURSES) && !defined(RENAMED_NCURSES)
+dnl    #include <ncurses.h>
+dnl    #else
+dnl    #include <curses.h>
+dnl    #endif
+dnl
+dnl 4) Make sure to add @CURSES_INCLUDEDIR@ to your preprocessor flags
+dnl 5) Make sure to add @CURSES_LIBS@ to your linker flags or LIBS
+dnl
+dnl Notes with automake:
+dnl - call AM_CONDITIONAL(HAS_CURSES, test "$has_curses" = true) from
+dnl   configure.in
+dnl - your Makefile.am can look something like this
+dnl   -----------------------------------------------
+dnl   INCLUDES= blah blah blah $(CURSES_INCLUDEDIR) 
+dnl   if HAS_CURSES
+dnl   CURSES_TARGETS=name_of_curses_prog
+dnl   endif
+dnl   bin_PROGRAMS = other_programs $(CURSES_TARGETS)
+dnl   other_programs_SOURCES = blah blah blah
+dnl   name_of_curses_prog_SOURCES = blah blah blah
+dnl   other_programs_LDADD = blah
+dnl   name_of_curses_prog_LDADD = blah $(CURSES_LIBS)
+dnl   -----------------------------------------------
+dnl
+dnl
+dnl The following lines should be added to acconfig.h:
+dnl ==================================================
+dnl
+dnl /*=== Curses version detection defines ===*/
+dnl /* Found some version of curses that we're going to use */
+dnl #undef HAS_CURSES
+dnl    
+dnl /* Use SunOS SysV curses? */
+dnl #undef USE_SUNOS_CURSES
+dnl 
+dnl /* Use old BSD curses - not used right now */
+dnl #undef USE_BSD_CURSES
+dnl 
+dnl /* Use SystemV curses? */
+dnl #undef USE_SYSV_CURSES
+dnl 
+dnl /* Use Ncurses? */
+dnl #undef USE_NCURSES
+dnl 
+dnl /* If you Curses does not have color define this one */
+dnl #undef NO_COLOR_CURSES
+dnl 
+dnl /* Define if you want to turn on SCO-specific code */
+dnl #undef SCO_FLAVOR
+dnl 
+dnl /* Set to reflect version of ncurses *
+dnl  *   0 = version 1.*
+dnl  *   1 = version 1.9.9g
+dnl  *   2 = version 4.0/4.1 */
+dnl #undef NCURSES_970530
+dnl
+dnl /*=== End new stuff for acconfig.h ===*/
+dnl 
+
+
+AC_DEFUN(AC_CHECK_CURSES,[
+	search_ncurses=true
+	screen_manager=""
+	has_curses=false
+
+	CFLAGS=${CFLAGS--O}
+
+	AC_SUBST(CURSES_LIBS)
+	AC_SUBST(CURSES_INCLUDEDIR)
+
+	AC_ARG_WITH(sco,
+	  [  --with-sco              Use this to turn on SCO-specific code],[
+	  if test x$withval = xyes; then
+		AC_DEFINE(SCO_FLAVOR)
+		CFLAGS="$CFLAGS -D_SVID3"
+	  fi
+	])
+
+	AC_ARG_WITH(sunos-curses,
+	  [  --with-sunos-curses     Used to force SunOS 4.x curses],[
+	  if test x$withval = xyes; then
+		AC_USE_SUNOS_CURSES
+	  fi
+	])
+
+	AC_ARG_WITH(osf1-curses,
+	  [  --with-osf1-curses      Used to force OSF/1 curses],[
+	  if test x$withval = xyes; then
+		AC_USE_OSF1_CURSES
+	  fi
+	])
+
+	AC_ARG_WITH(vcurses,
+	  [  --with-vcurses[=incdir] Used to force SysV curses],
+	  if test x$withval != xyes; then
+		CURSES_INCLUDEDIR="-I$withval"
+	  fi
+	  AC_USE_SYSV_CURSES
+	)
+
+	AC_ARG_WITH(ncurses,
+	  [  --with-ncurses[=dir]  Compile with ncurses/locate base dir],
+	  if test x$withval = xno ; then
+		search_ncurses=false
+	  elif test x$withval != xyes ; then
+		CURSES_LIBS="$LIBS -L$withval/lib -lncurses"
+		CURSES_INCLUDEDIR="-I$withval/include"
+		search_ncurses=false
+		screen_manager="ncurses"
+		AC_DEFINE(USE_NCURSES)
+		AC_DEFINE(HAS_CURSES)
+		has_curses=true
+	  fi
+	)
+
+	if $search_ncurses
+	then
+		AC_SEARCH_NCURSES()
+	fi
+
+
+])
+
+
+AC_DEFUN(AC_USE_SUNOS_CURSES, [
+	search_ncurses=false
+	screen_manager="SunOS 4.x /usr/5include curses"
+	AC_MSG_RESULT(Using SunOS 4.x /usr/5include curses)
+	AC_DEFINE(USE_SUNOS_CURSES)
+	AC_DEFINE(HAS_CURSES)
+	has_curses=true
+	AC_DEFINE(NO_COLOR_CURSES)
+	AC_DEFINE(USE_SYSV_CURSES)
+	CURSES_INCLUDEDIR="-I/usr/5include"
+	CURSES_LIBS="/usr/5lib/libcurses.a /usr/5lib/libtermcap.a"
+	AC_MSG_RESULT(Please note that some screen refreshs may fail)
+])
+
+AC_DEFUN(AC_USE_OSF1_CURSES, [
+       AC_MSG_RESULT(Using OSF1 curses)
+       search_ncurses=false
+       screen_manager="OSF1 curses"
+       AC_DEFINE(HAS_CURSES)
+       has_curses=true
+       AC_DEFINE(NO_COLOR_CURSES)
+       AC_DEFINE(USE_SYSV_CURSES)
+       CURSES_LIBS="-lcurses"
+])
+
+AC_DEFUN(AC_USE_SYSV_CURSES, [
+	AC_MSG_RESULT(Using SysV curses)
+	AC_DEFINE(HAS_CURSES)
+	has_curses=true
+	AC_DEFINE(USE_SYSV_CURSES)
+	search_ncurses=false
+	screen_manager="SysV/curses"
+	CURSES_LIBS="-lcurses"
+])
+
+dnl AC_ARG_WITH(bsd-curses,
+dnl [--with-bsd-curses         Used to compile with bsd curses, not very fancy],
+dnl 	search_ncurses=false
+dnl	screen_manager="Ultrix/cursesX"
+dnl	if test $system = ULTRIX
+dnl	then
+dnl	    THIS_CURSES=cursesX
+dnl        else
+dnl	    THIS_CURSES=curses
+dnl	fi
+dnl
+dnl	CURSES_LIBS="-l$THIS_CURSES -ltermcap"
+dnl	AC_DEFINE(HAS_CURSES)
+dnl	has_curses=true
+dnl	AC_DEFINE(USE_BSD_CURSES)
+dnl	AC_MSG_RESULT(Please note that some screen refreshs may fail)
+dnl	AC_MSG_WARN(Use of the bsdcurses extension has some)
+dnl	AC_MSG_WARN(display/input problems.)
+dnl	AC_MSG_WARN(Reconsider using xcurses)
+dnl)
+
+	
+dnl
+dnl Parameters: directory filename cureses_LIBS curses_INCLUDEDIR nicename
+dnl
+AC_DEFUN(AC_NCURSES, [
+    if $search_ncurses
+    then
+        if test -f $1/$2
+	then
+	    AC_MSG_RESULT(Found ncurses on $1/$2)
+ 	    CURSES_LIBS="$3"
+	    CURSES_INCLUDEDIR="$4"
+	    search_ncurses=false
+	    screen_manager=$5
+            AC_DEFINE(HAS_CURSES)
+            has_curses=true
+	    AC_DEFINE(USE_NCURSES)
+	fi
+    fi
+])
+
+AC_DEFUN(AC_SEARCH_NCURSES, [
+    AC_CHECKING("location of ncurses.h file")
+
+    AC_NCURSES(/usr/include, ncurses.h, -lncurses,, "ncurses on /usr/include")
+    AC_NCURSES(/usr/include/ncurses, ncurses.h, -lncurses, -I/usr/include/ncurses, "ncurses on /usr/include/ncurses")
+    AC_NCURSES(/usr/local/include, ncurses.h, -L/usr/local/lib -lncurses, -I/usr/local/include, "ncurses on /usr/local")
+    AC_NCURSES(/usr/local/include/ncurses, ncurses.h, -L/usr/local/lib -L/usr/local/lib/ncurses -lncurses, -I/usr/local/include/ncurses, "ncurses on /usr/local/include/ncurses")
+
+    AC_NCURSES(/usr/local/include/ncurses, curses.h, -L/usr/local/lib -lncurses, -I/usr/local/include/ncurses -DRENAMED_NCURSES, "renamed ncurses on /usr/local/.../ncurses")
+
+    AC_NCURSES(/usr/include/ncurses, curses.h, -lncurses, -I/usr/include/ncurses -DRENAMED_NCURSES, "renamed ncurses on /usr/include/ncurses")
+
+    dnl
+    dnl We couldn't find ncurses, try SysV curses
+    dnl
+    if $search_ncurses 
+    then
+        AC_EGREP_HEADER(init_color, /usr/include/curses.h,
+	    AC_USE_SYSV_CURSES)
+	AC_EGREP_CPP(USE_NCURSES,[
+#include <curses.h>
+#ifdef __NCURSES_H
+#undef USE_NCURSES
+USE_NCURSES
+#endif
+],[
+	CURSES_INCLUDEDIR="$CURSES_INCLUDEDIR -DRENAMED_NCURSES"
+        AC_DEFINE(HAS_CURSES)
+	has_curses=true
+        AC_DEFINE(USE_NCURSES)
+        search_ncurses=false
+        screen_manager="ncurses installed as curses"
+])
+    fi
+
+    dnl
+    dnl Try SunOS 4.x /usr/5{lib,include} ncurses
+    dnl The flags USE_SUNOS_CURSES, USE_BSD_CURSES and BUGGY_CURSES
+    dnl should be replaced by a more fine grained selection routine
+    dnl
+    if $search_ncurses
+    then
+	if test -f /usr/5include/curses.h
+	then
+	    AC_USE_SUNOS_CURSES
+        fi
+    else
+        # check for ncurses version, to properly ifdef mouse-fix
+	AC_MSG_CHECKING(for ncurses version)
+	ncurses_version=unknown
+cat > conftest.$ac_ext <<EOF
+[#]line __oline__ "configure"
+#include "confdefs.h"
+#ifdef RENAMED_NCURSES
+#include <curses.h>
+#else
+#include <ncurses.h>
+#endif
+#undef VERSION
+VERSION:NCURSES_VERSION
+EOF
+        if (eval "$ac_cpp conftest.$ac_ext") 2>&AC_FD_CC |
+  egrep "VERSION:" >conftest.out 2>&1; then
+changequote(,)dnl
+            ncurses_version=`cat conftest.out|sed -e 's/^[^"]*"//' -e 's/".*//'`
+changequote([,])dnl
+	fi
+	rm -rf conftest*
+        AC_MSG_RESULT($ncurses_version)
+	case "$ncurses_version" in
+changequote(,)dnl
+	4.[01])
+changequote([,])dnl
+            AC_DEFINE(NCURSES_970530,2)
+            ;;
+	1.9.9g)
+            AC_DEFINE(NCURSES_970530,1)
+            ;;
+	1*)
+            AC_DEFINE(NCURSES_970530,0)
+            ;;
+	esac
+    fi
+])
+
+
+
+
+
+
+# Define a conditional.
+
+AC_DEFUN(AM_CONDITIONAL,
+[AC_SUBST($1_TRUE)
+AC_SUBST($1_FALSE)
+if $2; then
+  $1_TRUE=
+  $1_FALSE='#'
+else
+  $1_TRUE='#'
+  $1_FALSE=
+fi])
+
+# Do all the work for Automake.  This macro actually does too much --
+# some checks are only needed if your package does certain things.
+# But this isn't really a big deal.
+
+# serial 1
+
+dnl Usage:
+dnl AM_INIT_AUTOMAKE(package,version, [no-define])
+
+AC_DEFUN(AM_INIT_AUTOMAKE,
+[AC_REQUIRE([AC_PROG_INSTALL])
+dnl We require 2.13 because we rely on SHELL being computed by configure.
+AC_PREREQ([2.13])
+PACKAGE=[$1]
+AC_SUBST(PACKAGE)
+VERSION=[$2]
+AC_SUBST(VERSION)
+dnl test to see if srcdir already configured
+if test "`cd $srcdir && pwd`" != "`pwd`" && test -f $srcdir/config.status; then
+  AC_MSG_ERROR([source directory already configured; run "make distclean" there first])
+fi
+ifelse([$3],,
+AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE", [Name of package])
+AC_DEFINE_UNQUOTED(VERSION, "$VERSION", [Version number of package]))
+AC_REQUIRE([AM_SANITY_CHECK])
+AC_REQUIRE([AC_ARG_PROGRAM])
+dnl FIXME This is truly gross.
+missing_dir=`cd $ac_aux_dir && pwd`
+AM_MISSING_PROG(ACLOCAL, aclocal, $missing_dir)
+AM_MISSING_PROG(AUTOCONF, autoconf, $missing_dir)
+AM_MISSING_PROG(AUTOMAKE, automake, $missing_dir)
+AM_MISSING_PROG(AUTOHEADER, autoheader, $missing_dir)
+AM_MISSING_PROG(MAKEINFO, makeinfo, $missing_dir)
+AC_REQUIRE([AC_PROG_MAKE_SET])])
+
+#
+# Check to make sure that the build environment is sane.
+#
+
+AC_DEFUN(AM_SANITY_CHECK,
+[AC_MSG_CHECKING([whether build environment is sane])
+# Just in case
+sleep 1
+echo timestamp > conftestfile
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt $srcdir/configure conftestfile 2> /dev/null`
+   if test "[$]*" = "X"; then
+      # -L didn't work.
+      set X `ls -t $srcdir/configure conftestfile`
+   fi
+   if test "[$]*" != "X $srcdir/configure conftestfile" \
+      && test "[$]*" != "X conftestfile $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
+alias in your environment])
+   fi
+
+   test "[$]2" = conftestfile
+   )
+then
+   # Ok.
+   :
+else
+   AC_MSG_ERROR([newly created file is older than distributed files!
+Check your system clock])
+fi
+rm -f conftest*
+AC_MSG_RESULT(yes)])
+
+dnl AM_MISSING_PROG(NAME, PROGRAM, DIRECTORY)
+dnl The program must properly implement --version.
+AC_DEFUN(AM_MISSING_PROG,
+[AC_MSG_CHECKING(for working $2)
+# Run test in a subshell; some versions of sh will print an error if
+# an executable is not found, even if stderr is redirected.
+# Redirect stdin to placate older versions of autoconf.  Sigh.
+if ($2 --version) < /dev/null > /dev/null 2>&1; then
+   $1=$2
+   AC_MSG_RESULT(found)
+else
+   $1="$3/missing $2"
+   AC_MSG_RESULT(missing)
+fi
+AC_SUBST($1)])
+
+# Like AC_CONFIG_HEADER, but automatically create stamp file.
+
+AC_DEFUN(AM_CONFIG_HEADER,
+[AC_PREREQ([2.12])
+AC_CONFIG_HEADER([$1])
+dnl When config.status generates a header, we must update the stamp-h file.
+dnl This file resides in the same directory as the config header
+dnl that is generated.  We must strip everything past the first ":",
+dnl and everything past the last "/".
+AC_OUTPUT_COMMANDS(changequote(<<,>>)dnl
+ifelse(patsubst(<<$1>>, <<[^ ]>>, <<>>), <<>>,
+<<test -z "<<$>>CONFIG_HEADERS" || echo timestamp > patsubst(<<$1>>, <<^\([^:]*/\)?.*>>, <<\1>>)stamp-h<<>>dnl>>,
+<<am_indx=1
+for am_file in <<$1>>; do
+  case " <<$>>CONFIG_HEADERS " in
+  *" <<$>>am_file "*<<)>>
+    echo timestamp > `echo <<$>>am_file | sed -e 's%:.*%%' -e 's%[^/]*$%%'`stamp-h$am_indx
+    ;;
+  esac
+  am_indx=`expr "<<$>>am_indx" + 1`
+done<<>>dnl>>)
+changequote([,]))])
+
+
+# serial 40 AC_PROG_LIBTOOL
+AC_DEFUN(AC_PROG_LIBTOOL,
+[AC_REQUIRE([AC_LIBTOOL_SETUP])dnl
+
+# Save cache, so that ltconfig can load it
+AC_CACHE_SAVE
+
+# Actually configure libtool.  ac_aux_dir is where install-sh is found.
+CC="$CC" CFLAGS="$CFLAGS" CPPFLAGS="$CPPFLAGS" \
+LD="$LD" LDFLAGS="$LDFLAGS" LIBS="$LIBS" \
+LN_S="$LN_S" NM="$NM" RANLIB="$RANLIB" \
+DLLTOOL="$DLLTOOL" AS="$AS" OBJDUMP="$OBJDUMP" \
+${CONFIG_SHELL-/bin/sh} $ac_aux_dir/ltconfig --no-reexec \
+$libtool_flags --no-verify $ac_aux_dir/ltmain.sh $lt_target \
+|| AC_MSG_ERROR([libtool configure failed])
+
+# Reload cache, that may have been modified by ltconfig
+AC_CACHE_LOAD
+
+# This can be used to rebuild libtool when needed
+LIBTOOL_DEPS="$ac_aux_dir/ltconfig $ac_aux_dir/ltmain.sh"
+
+# Always use our own libtool.
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
+AC_SUBST(LIBTOOL)dnl
+
+# Redirect the config.log output again, so that the ltconfig log is not
+# clobbered by the next message.
+exec 5>>./config.log
+])
+
+AC_DEFUN(AC_LIBTOOL_SETUP,
+[AC_PREREQ(2.13)dnl
+AC_REQUIRE([AC_ENABLE_SHARED])dnl
+AC_REQUIRE([AC_ENABLE_STATIC])dnl
+AC_REQUIRE([AC_ENABLE_FAST_INSTALL])dnl
+AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_CANONICAL_BUILD])dnl
+AC_REQUIRE([AC_PROG_RANLIB])dnl
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([AC_PROG_LD])dnl
+AC_REQUIRE([AC_PROG_NM])dnl
+AC_REQUIRE([AC_PROG_LN_S])dnl
+dnl
+
+case "$target" in
+NONE) lt_target="$host" ;;
+*) lt_target="$target" ;;
+esac
+
+# Check for any special flags to pass to ltconfig.
+#
+# the following will cause an existing older ltconfig to fail, so
+# we ignore this at the expense of the cache file... Checking this 
+# will just take longer ... bummer!
+#libtool_flags="--cache-file=$cache_file"
+#
+test "$enable_shared" = no && libtool_flags="$libtool_flags --disable-shared"
+test "$enable_static" = no && libtool_flags="$libtool_flags --disable-static"
+test "$enable_fast_install" = no && libtool_flags="$libtool_flags --disable-fast-install"
+test "$ac_cv_prog_gcc" = yes && libtool_flags="$libtool_flags --with-gcc"
+test "$ac_cv_prog_gnu_ld" = yes && libtool_flags="$libtool_flags --with-gnu-ld"
+ifdef([AC_PROVIDE_AC_LIBTOOL_DLOPEN],
+[libtool_flags="$libtool_flags --enable-dlopen"])
+ifdef([AC_PROVIDE_AC_LIBTOOL_WIN32_DLL],
+[libtool_flags="$libtool_flags --enable-win32-dll"])
+AC_ARG_ENABLE(libtool-lock,
+  [  --disable-libtool-lock  avoid locking (might break parallel builds)])
+test "x$enable_libtool_lock" = xno && libtool_flags="$libtool_flags --disable-lock"
+test x"$silent" = xyes && libtool_flags="$libtool_flags --silent"
+
+# Some flags need to be propagated to the compiler or linker for good
+# libtool support.
+case "$lt_target" in
+*-*-irix6*)
+  # Find out which ABI we are using.
+  echo '[#]line __oline__ "configure"' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    case "`/usr/bin/file conftest.o`" in
+    *32-bit*)
+      LD="${LD-ld} -32"
+      ;;
+    *N32*)
+      LD="${LD-ld} -n32"
+      ;;
+    *64-bit*)
+      LD="${LD-ld} -64"
+      ;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+
+*-*-sco3.2v5*)
+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
+  SAVE_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -belf"
+  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,
+    [AC_TRY_LINK([],[],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])])
+  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
+    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
+    CFLAGS="$SAVE_CFLAGS"
+  fi
+  ;;
+
+ifdef([AC_PROVIDE_AC_LIBTOOL_WIN32_DLL],
+[*-*-cygwin* | *-*-mingw*)
+  AC_CHECK_TOOL(DLLTOOL, dlltool, false)
+  AC_CHECK_TOOL(AS, as, false)
+  AC_CHECK_TOOL(OBJDUMP, objdump, false)
+  ;;
+])
+esac
+])
+
+# AC_LIBTOOL_DLOPEN - enable checks for dlopen support
+AC_DEFUN(AC_LIBTOOL_DLOPEN, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])])
+
+# AC_LIBTOOL_WIN32_DLL - declare package support for building win32 dll's
+AC_DEFUN(AC_LIBTOOL_WIN32_DLL, [AC_BEFORE([$0], [AC_LIBTOOL_SETUP])])
+
+# AC_ENABLE_SHARED - implement the --enable-shared flag
+# Usage: AC_ENABLE_SHARED[(DEFAULT)]
+#   Where DEFAULT is either `yes' or `no'.  If omitted, it defaults to
+#   `yes'.
+AC_DEFUN(AC_ENABLE_SHARED, [dnl
+define([AC_ENABLE_SHARED_DEFAULT], ifelse($1, no, no, yes))dnl
+AC_ARG_ENABLE(shared,
+changequote(<<, >>)dnl
+<<  --enable-shared[=PKGS]  build shared libraries [default=>>AC_ENABLE_SHARED_DEFAULT],
+changequote([, ])dnl
+[p=${PACKAGE-default}
+case "$enableval" in
+yes) enable_shared=yes ;;
+no) enable_shared=no ;;
+*)
+  enable_shared=no
+  # Look at the argument we got.  We use all the common list separators.
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:,"
+  for pkg in $enableval; do
+    if test "X$pkg" = "X$p"; then
+      enable_shared=yes
+    fi
+  done
+  IFS="$ac_save_ifs"
+  ;;
+esac],
+enable_shared=AC_ENABLE_SHARED_DEFAULT)dnl
+])
+
+# AC_DISABLE_SHARED - set the default shared flag to --disable-shared
+AC_DEFUN(AC_DISABLE_SHARED, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl
+AC_ENABLE_SHARED(no)])
+
+# AC_ENABLE_STATIC - implement the --enable-static flag
+# Usage: AC_ENABLE_STATIC[(DEFAULT)]
+#   Where DEFAULT is either `yes' or `no'.  If omitted, it defaults to
+#   `yes'.
+AC_DEFUN(AC_ENABLE_STATIC, [dnl
+define([AC_ENABLE_STATIC_DEFAULT], ifelse($1, no, no, yes))dnl
+AC_ARG_ENABLE(static,
+changequote(<<, >>)dnl
+<<  --enable-static[=PKGS]  build static libraries [default=>>AC_ENABLE_STATIC_DEFAULT],
+changequote([, ])dnl
+[p=${PACKAGE-default}
+case "$enableval" in
+yes) enable_static=yes ;;
+no) enable_static=no ;;
+*)
+  enable_static=no
+  # Look at the argument we got.  We use all the common list separators.
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:,"
+  for pkg in $enableval; do
+    if test "X$pkg" = "X$p"; then
+      enable_static=yes
+    fi
+  done
+  IFS="$ac_save_ifs"
+  ;;
+esac],
+enable_static=AC_ENABLE_STATIC_DEFAULT)dnl
+])
+
+# AC_DISABLE_STATIC - set the default static flag to --disable-static
+AC_DEFUN(AC_DISABLE_STATIC, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl
+AC_ENABLE_STATIC(no)])
+
+
+# AC_ENABLE_FAST_INSTALL - implement the --enable-fast-install flag
+# Usage: AC_ENABLE_FAST_INSTALL[(DEFAULT)]
+#   Where DEFAULT is either `yes' or `no'.  If omitted, it defaults to
+#   `yes'.
+AC_DEFUN(AC_ENABLE_FAST_INSTALL, [dnl
+define([AC_ENABLE_FAST_INSTALL_DEFAULT], ifelse($1, no, no, yes))dnl
+AC_ARG_ENABLE(fast-install,
+changequote(<<, >>)dnl
+<<  --enable-fast-install[=PKGS]  optimize for fast installation [default=>>AC_ENABLE_FAST_INSTALL_DEFAULT],
+changequote([, ])dnl
+[p=${PACKAGE-default}
+case "$enableval" in
+yes) enable_fast_install=yes ;;
+no) enable_fast_install=no ;;
+*)
+  enable_fast_install=no
+  # Look at the argument we got.  We use all the common list separators.
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:,"
+  for pkg in $enableval; do
+    if test "X$pkg" = "X$p"; then
+      enable_fast_install=yes
+    fi
+  done
+  IFS="$ac_save_ifs"
+  ;;
+esac],
+enable_fast_install=AC_ENABLE_FAST_INSTALL_DEFAULT)dnl
+])
+
+# AC_ENABLE_FAST_INSTALL - set the default to --disable-fast-install
+AC_DEFUN(AC_DISABLE_FAST_INSTALL, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl
+AC_ENABLE_FAST_INSTALL(no)])
+
+# AC_PROG_LD - find the path to the GNU or non-GNU linker
+AC_DEFUN(AC_PROG_LD,
+[AC_ARG_WITH(gnu-ld,
+[  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]],
+test "$withval" = no || with_gnu_ld=yes, with_gnu_ld=no)
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_CANONICAL_BUILD])dnl
+ac_prog=ld
+if test "$ac_cv_prog_gcc" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  AC_MSG_CHECKING([for ld used by GCC])
+  ac_prog=`($CC -print-prog-name=ld) 2>&5`
+  case "$ac_prog" in
+    # Accept absolute paths.
+changequote(,)dnl
+    [\\/]* | [A-Za-z]:[\\/]*)
+      re_direlt='/[^/][^/]*/\.\./'
+changequote([,])dnl
+      # Canonicalize the path of ld
+      ac_prog=`echo $ac_prog| sed 's%\\\\%/%g'`
+      while echo $ac_prog | grep "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`echo $ac_prog| sed "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  AC_MSG_CHECKING([for GNU ld])
+else
+  AC_MSG_CHECKING([for non-GNU ld])
+fi
+AC_CACHE_VAL(ac_cv_path_LD,
+[if test -z "$LD"; then
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}${PATH_SEPARATOR-:}"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      ac_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some GNU ld's only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      if "$ac_cv_path_LD" -v 2>&1 < /dev/null | egrep '(GNU|with BFD)' > /dev/null; then
+	test "$with_gnu_ld" != no && break
+      else
+	test "$with_gnu_ld" != yes && break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+else
+  ac_cv_path_LD="$LD" # Let the user override the test with a path.
+fi])
+LD="$ac_cv_path_LD"
+if test -n "$LD"; then
+  AC_MSG_RESULT($LD)
+else
+  AC_MSG_RESULT(no)
+fi
+test -z "$LD" && AC_MSG_ERROR([no acceptable ld found in \$PATH])
+AC_PROG_LD_GNU
+])
+
+AC_DEFUN(AC_PROG_LD_GNU,
+[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], ac_cv_prog_gnu_ld,
+[# I'd rather use --version here, but apparently some GNU ld's only accept -v.
+if $LD -v 2>&1 </dev/null | egrep '(GNU|with BFD)' 1>&5; then
+  ac_cv_prog_gnu_ld=yes
+else
+  ac_cv_prog_gnu_ld=no
+fi])
+])
+
+# AC_PROG_NM - find the path to a BSD-compatible name lister
+AC_DEFUN(AC_PROG_NM,
+[AC_MSG_CHECKING([for BSD-compatible nm])
+AC_CACHE_VAL(ac_cv_path_NM,
+[if test -n "$NM"; then
+  # Let the user override the test.
+  ac_cv_path_NM="$NM"
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}${PATH_SEPARATOR-:}"
+  for ac_dir in $PATH /usr/ccs/bin /usr/ucb /bin; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/nm || test -f $ac_dir/nm$ac_exeext ; then
+      # Check to see if the nm accepts a BSD-compat flag.
+      # Adding the `sed 1q' prevents false positives on HP-UX, which says:
+      #   nm: unknown option "B" ignored
+      if ($ac_dir/nm -B /dev/null 2>&1 | sed '1q'; exit 0) | egrep /dev/null >/dev/null; then
+	ac_cv_path_NM="$ac_dir/nm -B"
+	break
+      elif ($ac_dir/nm -p /dev/null 2>&1 | sed '1q'; exit 0) | egrep /dev/null >/dev/null; then
+	ac_cv_path_NM="$ac_dir/nm -p"
+	break
+      else
+	ac_cv_path_NM=${ac_cv_path_NM="$ac_dir/nm"} # keep the first match, but
+	continue # so that we can try to find one that supports BSD flags
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_NM" && ac_cv_path_NM=nm
+fi])
+NM="$ac_cv_path_NM"
+AC_MSG_RESULT([$NM])
+])
+
+# AC_CHECK_LIBM - check for math library
+AC_DEFUN(AC_CHECK_LIBM,
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+LIBM=
+case "$lt_target" in
+*-*-beos* | *-*-cygwin*)
+  # These system don't have libm
+  ;;
+*-ncr-sysv4.3*)
+  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM="-lmw")
+  AC_CHECK_LIB(m, main, LIBM="$LIBM -lm")
+  ;;
+*)
+  AC_CHECK_LIB(m, main, LIBM="-lm")
+  ;;
+esac
+])
+
+# AC_LIBLTDL_CONVENIENCE[(dir)] - sets LIBLTDL to the link flags for
+# the libltdl convenience library and INCLTDL to the include flags for
+# the libltdl header and adds --enable-ltdl-convenience to the
+# configure arguments.  Note that LIBLTDL and INCLTDL are not
+# AC_SUBSTed, nor is AC_CONFIG_SUBDIRS called.  If DIR is not
+# provided, it is assumed to be `libltdl'.  LIBLTDL will be prefixed
+# with '${top_builddir}/' and INCLTDL will be prefixed with
+# '${top_srcdir}/' (note the single quotes!).  If your package is not
+# flat and you're not using automake, define top_builddir and
+# top_srcdir appropriately in the Makefiles.
+AC_DEFUN(AC_LIBLTDL_CONVENIENCE, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl
+  case "$enable_ltdl_convenience" in
+  no) AC_MSG_ERROR([this package needs a convenience libltdl]) ;;
+  "") enable_ltdl_convenience=yes
+      ac_configure_args="$ac_configure_args --enable-ltdl-convenience" ;;
+  esac
+  LIBLTDL='${top_builddir}/'ifelse($#,1,[$1],['libltdl'])/libltdlc.la
+  INCLTDL='-I${top_srcdir}/'ifelse($#,1,[$1],['libltdl'])
+])
+
+# AC_LIBLTDL_INSTALLABLE[(dir)] - sets LIBLTDL to the link flags for
+# the libltdl installable library and INCLTDL to the include flags for
+# the libltdl header and adds --enable-ltdl-install to the configure
+# arguments.  Note that LIBLTDL and INCLTDL are not AC_SUBSTed, nor is
+# AC_CONFIG_SUBDIRS called.  If DIR is not provided and an installed
+# libltdl is not found, it is assumed to be `libltdl'.  LIBLTDL will
+# be prefixed with '${top_builddir}/' and INCLTDL will be prefixed
+# with '${top_srcdir}/' (note the single quotes!).  If your package is
+# not flat and you're not using automake, define top_builddir and
+# top_srcdir appropriately in the Makefiles.
+# In the future, this macro may have to be called after AC_PROG_LIBTOOL.
+AC_DEFUN(AC_LIBLTDL_INSTALLABLE, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl
+  AC_CHECK_LIB(ltdl, main,
+  [test x"$enable_ltdl_install" != xyes && enable_ltdl_install=no],
+  [if test x"$enable_ltdl_install" = xno; then
+     AC_MSG_WARN([libltdl not installed, but installation disabled])
+   else
+     enable_ltdl_install=yes
+   fi
+  ])
+  if test x"$enable_ltdl_install" = x"yes"; then
+    ac_configure_args="$ac_configure_args --enable-ltdl-install"
+    LIBLTDL='${top_builddir}/'ifelse($#,1,[$1],['libltdl'])/libltdl.la
+    INCLTDL='-I${top_srcdir}/'ifelse($#,1,[$1],['libltdl'])
+  else
+    ac_configure_args="$ac_configure_args --enable-ltdl-install=no"
+    LIBLTDL="-lltdl"
+    INCLTDL=
+  fi
+])
+
+dnl old names
+AC_DEFUN(AM_PROG_LIBTOOL, [indir([AC_PROG_LIBTOOL])])dnl
+AC_DEFUN(AM_ENABLE_SHARED, [indir([AC_ENABLE_SHARED], $@)])dnl
+AC_DEFUN(AM_ENABLE_STATIC, [indir([AC_ENABLE_STATIC], $@)])dnl
+AC_DEFUN(AM_DISABLE_SHARED, [indir([AC_DISABLE_SHARED], $@)])dnl
+AC_DEFUN(AM_DISABLE_STATIC, [indir([AC_DISABLE_STATIC], $@)])dnl
+AC_DEFUN(AM_PROG_LD, [indir([AC_PROG_LD])])dnl
+AC_DEFUN(AM_PROG_NM, [indir([AC_PROG_NM])])dnl
+
+dnl This is just to silence aclocal about the macro not being used
+ifelse([AC_DISABLE_FAST_INSTALL])dnl
+
diff -Nru dalc-0.1/configure.in dalc-0.1.new/configure.in
--- dalc-0.1/configure.in	Thu Jan  1 01:00:00 1970
+++ dalc-0.1.new/configure.in	Fri Nov 24 16:28:43 2000
@@ -0,0 +1,32 @@
+dnl Process this file with autoconf to produce a configure script.
+AC_INIT(dalexpr.h)
+
+AM_INIT_AUTOMAKE(dalc, 0.1)
+AM_CONFIG_HEADER(config.h)
+
+dnl Checks for programs.
+AC_PROG_CXX
+AC_PROG_INSTALL
+AM_PROG_LIBTOOL
+
+dnl Checks for libraries.
+dnl Replace `main' with a function in -lm:
+AC_CHECK_LIB(m, main)
+dnl Replace `main' with a function in -lmenu:
+AC_CHECK_LIB(menu, main)
+dnl Replace `main' with a function in -lncurses:
+AC_CHECK_LIB(ncurses, main)
+
+dnl Checks for header files.
+AC_HEADER_STDC
+AC_CHECK_HEADERS(unistd.h)
+
+dnl Checks for typedefs, structures, and compiler characteristics.
+AC_C_CONST
+
+dnl Checks for library functions.
+AC_CHECK_FUNCS(strerror strstr)
+
+AC_CHECK_CURSES
+
+AC_OUTPUT(Makefile)
diff -Nru dalc-0.1/dalc.C dalc-0.1.new/dalc.C
--- dalc-0.1/dalc.C	Thu Dec  9 08:01:35 1999
+++ dalc-0.1.new/dalc.C	Thu Jan  1 01:00:00 1970
@@ -1,495 +0,0 @@
-/*
- * Dalc
- * A powerful scientific DAL calculator
- * Copyright (C) 1999 Daniel Beer
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <ncurses.h>
-#include <menu.h>
-#include <stdio.h>
-#include <strings.h>
-#include <ctype.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <math.h>
-#include <errno.h>
-#include "dalexpr.h"
-
-#define MAXITEMS            12
-#define MAXINPUT            70
-#define HISTORY             10
-#define LMARGIN             2
-#define MAXMSG              8
-#define MSGSIZE             80
-#define MAXSTAT             100
-#define GSIZE               321
-#define GSPACE              32
-
-typedef void (*callback_t)(void);
-
-DALExpr foo;
-
-struct {
-  char text[MAXINPUT];
-  unsigned int x;
-} history[HISTORY];
-
-struct {
-  int a, b, c;
-} csc;
-
-struct {
-  MENU *foo;
-  ITEM *bar[MAXITEMS];
-  callback_t funcs[MAXITEMS];
-  int s, max;
-} menu;
-
-struct {
-  double val;
-  int freq;
-} stats[MAXSTAT];
-int numstat;
-
-double xpoints[MAXSTAT], ypoints[MAXSTAT];
-int numpoints;
-char messages[MAXMSG][MSGSIZE];
-
-void
-addMessage(char *text) {
-  int i;
-
-  for(i=MAXMSG-1;i;i--) strcpy(messages[i], messages[i-1]);
-  strncpy(messages[0], text, MSGSIZE);
-}
-
-void
-drawScreen(void) {
-  int i;
-
-  bkgdset(csc.a);
-  clear();
-  for(i=0;i<MAXMSG;i++) mvaddstr(LINES-3-i, 0, messages[i]);
-  bkgdset(csc.b);
-  mvaddstr(LINES-2, 0, "  Dalc version 0.1");
-  clrtoeol();
-  mvaddstr(LINES-2, COLS/2, "Copyright (C) 1999 Daniel Beer");
-}
-
-void
-quitProg(void) {
-  FILE *io;
-  int i;
-  char inp[200];
-
-  endwin();
-  sprintf(inp, "%s/.dalcrc", getenv("HOME"));
-  if((io=fopen(inp, "w"))!=NULL) {
-    fprintf(io, "%e %e\n", foo.dtr, foo.ans);
-    for(i=0;i<26;i++) fprintf(io, "%e\n", foo.vars[i]);
-    fclose(io);
-  }
-  exit(0);
-}
-
-void
-loadStats(void) {
-  char inp[50];
-  char *temp;
-  FILE *io;
-
-  bkgdset(csc.c);
-  mvaddstr(LINES-1, 0, "Stats file: ");
-  bkgdset(csc.a);
-  clrtoeol();
-  echo();
-  getnstr(inp, sizeof(inp));
-  noecho();
-  if((io=fopen(inp, "r"))==NULL) {
-    addMessage(strerror(errno));
-    return;
-  }
-  foo.vars[13]=0;
-  numstat=0;
-  fscanf(io, "%s", inp);
-  while(!feof(io)) {
-    temp=strstr(inp, ";");
-    if(temp==NULL) {
-      stats[numstat].val=atof(inp);
-      stats[numstat].freq=1;
-      foo.vars[13]+=1.0;
-    } else {
-      temp++[0]=0;
-      stats[numstat].val=atof(inp);
-      stats[numstat].freq=atoi(temp);
-      foo.vars[13]+=stats[numstat].freq;
-    }
-    if(numstat<MAXSTAT-1) numstat++;
-    fscanf(io, "%s", inp);
-  }
-  fclose(io);
-}
-
-void
-loadPoints(void) {
-  char inp[50];
-  char *temp;
-  FILE *io;
-
-  bkgdset(csc.c);
-  mvaddstr(LINES-1, 0, "Points file: ");
-  bkgdset(csc.a);
-  clrtoeol();
-  echo();
-  getnstr(inp, sizeof(inp));
-  noecho();
-  if((io=fopen(inp, "r"))==NULL) {
-    addMessage(strerror(errno));
-    return;
-  }
-  fscanf(io, "%s", inp);
-  numpoints=0;
-  while(!feof(io)) {
-    temp=strstr(inp, ",");
-    if(temp!=NULL) {
-      temp++[0]=0;
-      if(temp[0]=='_') temp[0]='-';
-    }
-    if(inp[0]=='_') inp[0]='-';
-    xpoints[numpoints]=atof(inp);
-    ypoints[numpoints]=atof(temp);
-    if(numpoints<MAXSTAT-1) numpoints++;
-    fscanf(io, "%s", inp);
-  }
-  fclose(io);
-}
-
-void
-angleRadians(void) {
-  foo.dtr=1.0;
-  addMessage("Working in radians.");
-}
-
-void
-angleDegrees(void) {
-  foo.dtr=M_PI/180.0;
-  addMessage("Working in degrees.");
-}
-
-void
-angleCustom(void) {
-  char inp[50];
-
-  bkgdset(csc.c);
-  mvaddstr(LINES-1, 0, "Number of units in a circle: ");
-  bkgdset(csc.a);
-  clrtoeol();
-  echo();
-  getnstr(inp, sizeof(inp));
-  noecho();
-  foo.dtr=(M_PI*2)/atof(inp);
-}
-
-void
-saveVar(void) {
-  int k;
-
-  bkgdset(csc.c);
-  mvaddstr(LINES-1, 0, "Variable (A-Z) or F2 to cancel: ");
-  k=0;
-  while(!isalpha(k)) {
-    k=getch();
-    if(k==KEY_F(2)) return;
-  }
-  if(islower(k)) k-=32;
-  foo.vars[k-'A']=foo.ans;
-}
-
-void
-sumStat(void) {
-  char inp[200];
-  int i;
-  float sum=0.0;
-
-  bkgdset(csc.c);
-  mvaddstr(LINES-1, 0, "Expression: ");
-  bkgdset(csc.a);
-  clrtoeol();
-  echo();
-  getnstr(inp, sizeof(inp));
-  noecho();
-  for(i=0;i<numstat;i++) {
-    foo.vars[23]=stats[i].val;
-    foo.evaluate(inp);
-    sum+=foo.ans*stats[i].freq;
-  }
-  foo.ans=sum;
-  addMessage(inp);
-  addMessage("");
-  snprintf(messages[0], MSGSIZE, " (sum) = %e, %f", foo.ans, foo.ans);
-}
-
-void
-quadratic(void) {
-  double x;
-
-  x=foo.regressQuadratic(xpoints, ypoints, numpoints);
-  addMessage("");
-  snprintf(messages[0], MSGSIZE, "Match = %f", x);
-  addMessage("");
-  snprintf(messages[0], MSGSIZE, "f(X) = %fX^2 + %fX + %f",
-	   foo.coeff.a, foo.coeff.b, foo.coeff.c);
-  addMessage("");
-  snprintf(messages[0], MSGSIZE, "fd(X) = %fX + %f",
-	   foo.coeff.a*2, foo.coeff.b);
-  addMessage("");
-  snprintf(messages[0], MSGSIZE, "fi(X) = %fX^3 + %fX^2 + %fX",
-	   foo.coeff.a/3, foo.coeff.b/2, foo.coeff.c);
-}
-
-void
-linear(void) {
-  double x;
-  x=foo.regressLinear(xpoints, ypoints, numpoints);
-  addMessage("");
-  snprintf(messages[0], MSGSIZE, "Match = %f", x);
-  addMessage("");
-  snprintf(messages[0], MSGSIZE, "f(X) = %fX + %f",
-	   foo.coeff.a, foo.coeff.b);
-  addMessage("");
-  snprintf(messages[0], MSGSIZE, "fd(X) = %f",
-	   foo.coeff.a);
-  addMessage("");
-  snprintf(messages[0], MSGSIZE, "fi(X) = %fX^2 + %fX",
-	   foo.coeff.a/2, foo.coeff.b);
-}
-
-void
-graphFunc(void) {
-  char inp[200], inp2[200];
-  int values[GSIZE+1], valuesS[GSIZE+1];
-  int x, y;
-  FILE *io;
-
-  bkgdset(csc.c);
-  mvaddstr(LINES-1, 0, "Function: ");
-  bkgdset(csc.a);
-  clrtoeol();
-  echo();
-  getnstr(inp, sizeof(inp));
-  noecho();
-  bkgdset(csc.c);
-  mvaddstr(LINES-1, 0, "Second function (enter if none): ");
-  bkgdset(csc.a);
-  clrtoeol();
-  echo();
-  getnstr(inp2, sizeof(inp2));
-  noecho();
-  for(x=0;x<=GSIZE;x++) {
-    foo.vars[23]=((double)x-GSIZE/2)/GSPACE;
-    foo.evaluate(inp);
-    values[x]=(int)((0.0-foo.ans)*GSPACE+GSIZE/2);
-  }
-  if(inp2[0]) {
-    for(x=0;x<=GSIZE;x++) {
-      foo.vars[23]=((double)x-GSIZE/2)/GSPACE;
-      foo.evaluate(inp2);
-      valuesS[x]=(int)((0.0-foo.ans)*GSPACE+GSIZE/2);
-    }
-  }
-  sprintf(inp, "/tmp/dalc%d.ppm", getpid());
-  if((io=fopen(inp, "w"))==NULL) {
-    addMessage(strerror(errno));
-    return;
-  }
-  fprintf(io, "P6\n%d %d\n255\n", GSIZE, GSIZE);
-  for(y=0;y<GSIZE;y++) for(x=0;x<GSIZE;x++) {
-    if(y>=values[x]&&y<=values[x+1]) fprintf(io, "%c%c%c", 0, 0, 0);
-    else if(y<=values[x]&&y>=values[x+1]) fprintf(io, "%c%c%c", 0, 0, 0);
-    else if(y>=valuesS[x]&&y<=valuesS[x+1]&&inp2[0])
-      fprintf(io, "%c%c%c", 192, 0, 0);
-    else if(y<=valuesS[x]&&y>=valuesS[x+1]&&inp2[0])
-      fprintf(io, "%c%c%c", 192, 0, 0);
-    else if(abs(x-GSIZE/2)<=1||abs(y-GSIZE/2)<=1||!(x%GSPACE&&y%GSPACE))
-      fprintf(io, "%c%c%c", 0, 0, 192);
-    else fprintf(io, "%c%c%c", 255, 255, 255);
-  }
-  fclose(io);
-  if(getenv("DISPLAY")!=NULL) {
-    switch(fork()) {
-    case -1:
-      addMessage(strerror(errno));
-      break;
-    case 0:
-      execlp(VIEWER, VIEWER, inp, NULL);
-      exit(-1);
-    }
-  }
-  bkgdset(csc.c);
-  mvaddstr(LINES-1, 0, "Save file as (*.gif, press enter to not save): ");
-  bkgdset(csc.a);
-  clrtoeol();
-  echo();
-  getnstr(inp2, sizeof(inp2));
-  noecho();
-  if(inp2[0]) {
-    sprintf(inp, "%s /tmp/dalc%d.ppm > %s", CONVERTER, getpid(), inp2);
-    if(system(inp)<0) addMessage(strerror(errno));
-  }
-  snprintf(inp, sizeof(inp), "/tmp/dalc%d.ppm", getpid());
-  unlink(inp);
-}
-
-void
-init(void) {
-  int i;
-  FILE *io;
-  char inp[200];
-
-  sprintf(inp, "%s/.dalcrc", getenv("HOME"));
-  if((io=fopen(inp, "r"))!=NULL) {
-    fscanf(io, "%le%le", &foo.dtr, &foo.ans);
-    for(i=0;i<26;i++) fscanf(io, "%le", &foo.vars[i]);
-    fclose(io);
-  }
-
-  for(i=0;i<MAXMSG;i++) messages[i][0]=0;
-  addMessage("Press F2 to toggle a menu.");
-
-  menu.s=0;
-  menu.bar[0]=new_item(" Store ", " Store last result as a variable. ");
-  menu.funcs[0]=saveVar;
-  menu.bar[1]=new_item(" Load stats ", " Load statistical data from file. ");
-  menu.funcs[1]=loadStats;
-  menu.bar[2]=new_item(" Sumstat ", " Evaluate an expression for each stat. ");
-  menu.funcs[2]=sumStat;
-  menu.bar[3]=new_item(" Graph ", " Graph a function. ");
-  menu.funcs[3]=graphFunc;
-  menu.bar[4]=new_item(" Load points ", " Load graph points from a file. ");
-  menu.funcs[4]=loadPoints;
-  menu.bar[5]=new_item(" Quadratic ", " Attempt a quadratic regression. ");
-  menu.funcs[5]=quadratic;
-  menu.bar[6]=new_item(" Linear ", " Attempt a linear regression. ");
-  menu.funcs[6]=linear;
-  menu.bar[7]=new_item(" Radians ", " Measure angles in radians. ");
-  menu.funcs[7]=angleRadians;
-  menu.bar[8]=new_item(" Degrees ", " Measure angles in degrees. ");
-  menu.funcs[8]=angleDegrees;
-  menu.bar[9]=new_item(" Custom angles ", 
-		       " Specify an angular measurement system. ");
-  menu.funcs[9]=angleCustom;
-  menu.bar[10]=new_item(" Exit ", " Exit the program. ");
-  menu.funcs[10]=quitProg;
-  menu.bar[11]=NULL;
-  menu.max=11;
-  menu.foo=new_menu(menu.bar);
-  set_menu_mark(menu.foo, "* ");
-
-  csc.a=A_NORMAL;
-  csc.b=A_REVERSE;
-  csc.c=A_BOLD;
-}
-
-void
-showMenu(void) {
-  int k=0;
-
-  post_menu(menu.foo);
-  while(k!=KEY_F(2)) {
-    k=getch();
-    switch(k) {
-    case KEY_UP:
-      if(--menu.s<0) menu.s=menu.max-1;
-      set_current_item(menu.foo, menu.bar[menu.s]);
-      break;
-    case KEY_DOWN:
-      if(++menu.s>=menu.max) menu.s=0;
-      set_current_item(menu.foo, menu.bar[menu.s]);
-      break;
-    case '\n':
-      menu.funcs[menu.s]();
-      k=KEY_F(2);
-      break;
-    }
-  }
-  unpost_menu(menu.foo);
-  drawScreen();
-}
-
-void
-expressionMode(void) {
-  unsigned int k=0, y=0, i, j;
-
-  history[y].text[0]=0;
-  history[y].x=0;
-  drawScreen();
-  for(;;) {
-    bkgdset(csc.c);
-    mvaddstr(LINES-1, 0, "> ");
-    bkgdset(csc.a);
-    addstr(history[y].text);
-    clrtoeol();
-    move(LINES-1, history[y].x+LMARGIN);
-    k=getch();
-    if(k>=' '&&k<127&&(j=strlen(history[y].text))<MAXINPUT-1) {
-      history[y].text[j+1]=0;
-      for(i=j;i>history[y].x;i--) history[y].text[i]=history[y].text[i-1];
-      history[y].text[history[y].x++]=k;
-    } else if((k==8||k==127||k==KEY_BACKSPACE)&&
-	      history[y].text[0]&&history[y].x) {
-      j=strlen(history[y].text);
-      history[y].x--;
-      for(i=history[y].x;i<j;) history[y].text[i]=history[y].text[++i];
-    } else if(k==4&&history[y].x<strlen(history[y].text)) {
-      j=strlen(history[y].text);
-      for(i=history[y].x;i<j;) history[y].text[i]=history[y].text[++i];
-    } else if(k==KEY_LEFT&&history[y].x) history[y].x--;
-    else if(k==KEY_RIGHT&&history[y].x<strlen(history[y].text)) history[y].x++;
-    else if(k==KEY_F(2)) showMenu();
-    else if(k==1) history[y].x=0;
-    else if(k==5) history[y].x=strlen(history[y].text);
-    else if(k=='\n'&&history[y].text[0]) {
-      foo.evaluate(history[y].text);
-      addMessage(history[y].text);
-      addMessage("");
-      snprintf(messages[0], MSGSIZE, " = %e, %f", foo.ans, foo.ans);
-      drawScreen();
-      strcpy(history[0].text, history[y].text);
-      history[0].x=history[y].x;
-      for(i=HISTORY-1;i;i--) {
-	history[i].x=history[i-1].x;
-	strcpy(history[i].text, history[i-1].text);
-      }
-      history[0].text[0]=0;
-      history[0].x=0;
-      y=0;
-    } else if(k==KEY_UP&&y<HISTORY-1) y++;
-    else if(k==KEY_DOWN&&y) y--;
-    else if(k==12) drawScreen();
-  }
-}
-
-int
-main(void) {
-  initscr();
-  cbreak();
-  noecho();
-  keypad(stdscr, TRUE);
-  init();
-  expressionMode();
-  endwin();
-}
diff -Nru dalc-0.1/dalc.cc dalc-0.1.new/dalc.cc
--- dalc-0.1/dalc.cc	Thu Jan  1 01:00:00 1970
+++ dalc-0.1.new/dalc.cc	Fri Nov 24 15:58:24 2000
@@ -0,0 +1,495 @@
+/*
+ * Dalc
+ * A powerful scientific DAL calculator
+ * Copyright (C) 1999 Daniel Beer
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <ncurses.h>
+#include <menu.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <math.h>
+#include <errno.h>
+#include "dalexpr.h"
+
+#define MAXITEMS            12
+#define MAXINPUT            70
+#define HISTORY             10
+#define LMARGIN             2
+#define MAXMSG              8
+#define MSGSIZE             80
+#define MAXSTAT             100
+#define GSIZE               321
+#define GSPACE              32
+
+typedef void (*callback_t)(void);
+
+DALExpr foo;
+
+struct {
+  char text[MAXINPUT];
+  unsigned int x;
+} history[HISTORY];
+
+struct {
+  int a, b, c;
+} csc;
+
+struct {
+  MENU *foo;
+  ITEM *bar[MAXITEMS];
+  callback_t funcs[MAXITEMS];
+  int s, max;
+} menu;
+
+struct {
+  double val;
+  int freq;
+} stats[MAXSTAT];
+int numstat;
+
+double xpoints[MAXSTAT], ypoints[MAXSTAT];
+int numpoints;
+char messages[MAXMSG][MSGSIZE];
+
+void
+addMessage(char *text) {
+  int i;
+
+  for(i=MAXMSG-1;i;i--) strcpy(messages[i], messages[i-1]);
+  strncpy(messages[0], text, MSGSIZE);
+}
+
+void
+drawScreen(void) {
+  int i;
+
+  bkgdset(csc.a);
+  clear();
+  for(i=0;i<MAXMSG;i++) mvaddstr(LINES-3-i, 0, messages[i]);
+  bkgdset(csc.b);
+  mvaddstr(LINES-2, 0, "  Dalc version 0.1");
+  clrtoeol();
+  mvaddstr(LINES-2, COLS/2, "Copyright (C) 1999 Daniel Beer");
+}
+
+void
+quitProg(void) {
+  FILE *io;
+  int i;
+  char inp[200];
+
+  endwin();
+  sprintf(inp, "%s/.dalcrc", getenv("HOME"));
+  if((io=fopen(inp, "w"))!=NULL) {
+    fprintf(io, "%e %e\n", foo.dtr, foo.ans);
+    for(i=0;i<26;i++) fprintf(io, "%e\n", foo.vars[i]);
+    fclose(io);
+  }
+  exit(0);
+}
+
+void
+loadStats(void) {
+  char inp[50];
+  char *temp;
+  FILE *io;
+
+  bkgdset(csc.c);
+  mvaddstr(LINES-1, 0, "Stats file: ");
+  bkgdset(csc.a);
+  clrtoeol();
+  echo();
+  getnstr(inp, sizeof(inp));
+  noecho();
+  if((io=fopen(inp, "r"))==NULL) {
+    addMessage(strerror(errno));
+    return;
+  }
+  foo.vars[13]=0;
+  numstat=0;
+  fscanf(io, "%s", inp);
+  while(!feof(io)) {
+    temp=strstr(inp, ";");
+    if(temp==NULL) {
+      stats[numstat].val=atof(inp);
+      stats[numstat].freq=1;
+      foo.vars[13]+=1.0;
+    } else {
+      temp++[0]=0;
+      stats[numstat].val=atof(inp);
+      stats[numstat].freq=atoi(temp);
+      foo.vars[13]+=stats[numstat].freq;
+    }
+    if(numstat<MAXSTAT-1) numstat++;
+    fscanf(io, "%s", inp);
+  }
+  fclose(io);
+}
+
+void
+loadPoints(void) {
+  char inp[50];
+  char *temp;
+  FILE *io;
+
+  bkgdset(csc.c);
+  mvaddstr(LINES-1, 0, "Points file: ");
+  bkgdset(csc.a);
+  clrtoeol();
+  echo();
+  getnstr(inp, sizeof(inp));
+  noecho();
+  if((io=fopen(inp, "r"))==NULL) {
+    addMessage(strerror(errno));
+    return;
+  }
+  fscanf(io, "%s", inp);
+  numpoints=0;
+  while(!feof(io)) {
+    temp=strstr(inp, ",");
+    if(temp!=NULL) {
+      temp++[0]=0;
+      if(temp[0]=='_') temp[0]='-';
+    }
+    if(inp[0]=='_') inp[0]='-';
+    xpoints[numpoints]=atof(inp);
+    ypoints[numpoints]=atof(temp);
+    if(numpoints<MAXSTAT-1) numpoints++;
+    fscanf(io, "%s", inp);
+  }
+  fclose(io);
+}
+
+void
+angleRadians(void) {
+  foo.dtr=1.0;
+  addMessage("Working in radians.");
+}
+
+void
+angleDegrees(void) {
+  foo.dtr=M_PI/180.0;
+  addMessage("Working in degrees.");
+}
+
+void
+angleCustom(void) {
+  char inp[50];
+
+  bkgdset(csc.c);
+  mvaddstr(LINES-1, 0, "Number of units in a circle: ");
+  bkgdset(csc.a);
+  clrtoeol();
+  echo();
+  getnstr(inp, sizeof(inp));
+  noecho();
+  foo.dtr=(M_PI*2)/atof(inp);
+}
+
+void
+saveVar(void) {
+  int k;
+
+  bkgdset(csc.c);
+  mvaddstr(LINES-1, 0, "Variable (A-Z) or F2 to cancel: ");
+  k=0;
+  while(!isalpha(k)) {
+    k=getch();
+    if(k==KEY_F(2)) return;
+  }
+  if(islower(k)) k-=32;
+  foo.vars[k-'A']=foo.ans;
+}
+
+void
+sumStat(void) {
+  char inp[200];
+  int i;
+  float sum=0.0;
+
+  bkgdset(csc.c);
+  mvaddstr(LINES-1, 0, "Expression: ");
+  bkgdset(csc.a);
+  clrtoeol();
+  echo();
+  getnstr(inp, sizeof(inp));
+  noecho();
+  for(i=0;i<numstat;i++) {
+    foo.vars[23]=stats[i].val;
+    foo.evaluate(inp);
+    sum+=foo.ans*stats[i].freq;
+  }
+  foo.ans=sum;
+  addMessage(inp);
+  addMessage("");
+  snprintf(messages[0], MSGSIZE, " (sum) = %e, %f", foo.ans, foo.ans);
+}
+
+void
+quadratic(void) {
+  double x;
+
+  x=foo.regressQuadratic(xpoints, ypoints, numpoints);
+  addMessage("");
+  snprintf(messages[0], MSGSIZE, "Match = %f", x);
+  addMessage("");
+  snprintf(messages[0], MSGSIZE, "f(X) = %fX^2 + %fX + %f",
+	   foo.coeff.a, foo.coeff.b, foo.coeff.c);
+  addMessage("");
+  snprintf(messages[0], MSGSIZE, "fd(X) = %fX + %f",
+	   foo.coeff.a*2, foo.coeff.b);
+  addMessage("");
+  snprintf(messages[0], MSGSIZE, "fi(X) = %fX^3 + %fX^2 + %fX",
+	   foo.coeff.a/3, foo.coeff.b/2, foo.coeff.c);
+}
+
+void
+linear(void) {
+  double x;
+  x=foo.regressLinear(xpoints, ypoints, numpoints);
+  addMessage("");
+  snprintf(messages[0], MSGSIZE, "Match = %f", x);
+  addMessage("");
+  snprintf(messages[0], MSGSIZE, "f(X) = %fX + %f",
+	   foo.coeff.a, foo.coeff.b);
+  addMessage("");
+  snprintf(messages[0], MSGSIZE, "fd(X) = %f",
+	   foo.coeff.a);
+  addMessage("");
+  snprintf(messages[0], MSGSIZE, "fi(X) = %fX^2 + %fX",
+	   foo.coeff.a/2, foo.coeff.b);
+}
+
+void
+graphFunc(void) {
+  char inp[200], inp2[200];
+  int values[GSIZE+1], valuesS[GSIZE+1];
+  int x, y;
+  FILE *io;
+
+  bkgdset(csc.c);
+  mvaddstr(LINES-1, 0, "Function: ");
+  bkgdset(csc.a);
+  clrtoeol();
+  echo();
+  getnstr(inp, sizeof(inp));
+  noecho();
+  bkgdset(csc.c);
+  mvaddstr(LINES-1, 0, "Second function (enter if none): ");
+  bkgdset(csc.a);
+  clrtoeol();
+  echo();
+  getnstr(inp2, sizeof(inp2));
+  noecho();
+  for(x=0;x<=GSIZE;x++) {
+    foo.vars[23]=((double)x-GSIZE/2)/GSPACE;
+    foo.evaluate(inp);
+    values[x]=(int)((0.0-foo.ans)*GSPACE+GSIZE/2);
+  }
+  if(inp2[0]) {
+    for(x=0;x<=GSIZE;x++) {
+      foo.vars[23]=((double)x-GSIZE/2)/GSPACE;
+      foo.evaluate(inp2);
+      valuesS[x]=(int)((0.0-foo.ans)*GSPACE+GSIZE/2);
+    }
+  }
+  sprintf(inp, "/tmp/dalc%d.ppm", getpid());
+  if((io=fopen(inp, "w"))==NULL) {
+    addMessage(strerror(errno));
+    return;
+  }
+  fprintf(io, "P6\n%d %d\n255\n", GSIZE, GSIZE);
+  for(y=0;y<GSIZE;y++) for(x=0;x<GSIZE;x++) {
+    if(y>=values[x]&&y<=values[x+1]) fprintf(io, "%c%c%c", 0, 0, 0);
+    else if(y<=values[x]&&y>=values[x+1]) fprintf(io, "%c%c%c", 0, 0, 0);
+    else if(y>=valuesS[x]&&y<=valuesS[x+1]&&inp2[0])
+      fprintf(io, "%c%c%c", 192, 0, 0);
+    else if(y<=valuesS[x]&&y>=valuesS[x+1]&&inp2[0])
+      fprintf(io, "%c%c%c", 192, 0, 0);
+    else if(abs(x-GSIZE/2)<=1||abs(y-GSIZE/2)<=1||!(x%GSPACE&&y%GSPACE))
+      fprintf(io, "%c%c%c", 0, 0, 192);
+    else fprintf(io, "%c%c%c", 255, 255, 255);
+  }
+  fclose(io);
+  if(getenv("DISPLAY")!=NULL) {
+    switch(fork()) {
+    case -1:
+      addMessage(strerror(errno));
+      break;
+    case 0:
+      execlp(VIEWER, VIEWER, inp, NULL);
+      exit(-1);
+    }
+  }
+  bkgdset(csc.c);
+  mvaddstr(LINES-1, 0, "Save file as (*.gif, press enter to not save): ");
+  bkgdset(csc.a);
+  clrtoeol();
+  echo();
+  getnstr(inp2, sizeof(inp2));
+  noecho();
+  if(inp2[0]) {
+    sprintf(inp, "%s /tmp/dalc%d.ppm > %s", CONVERTER, getpid(), inp2);
+    if(system(inp)<0) addMessage(strerror(errno));
+  }
+  snprintf(inp, sizeof(inp), "/tmp/dalc%d.ppm", getpid());
+  unlink(inp);
+}
+
+void
+init(void) {
+  int i;
+  FILE *io;
+  char inp[200];
+
+  sprintf(inp, "%s/.dalcrc", getenv("HOME"));
+  if((io=fopen(inp, "r"))!=NULL) {
+    fscanf(io, "%le%le", &foo.dtr, &foo.ans);
+    for(i=0;i<26;i++) fscanf(io, "%le", &foo.vars[i]);
+    fclose(io);
+  }
+
+  for(i=0;i<MAXMSG;i++) messages[i][0]=0;
+  addMessage("Press F2 to toggle a menu.");
+
+  menu.s=0;
+  menu.bar[0]=new_item(" Store ", " Store last result as a variable. ");
+  menu.funcs[0]=saveVar;
+  menu.bar[1]=new_item(" Load stats ", " Load statistical data from file. ");
+  menu.funcs[1]=loadStats;
+  menu.bar[2]=new_item(" Sumstat ", " Evaluate an expression for each stat. ");
+  menu.funcs[2]=sumStat;
+  menu.bar[3]=new_item(" Graph ", " Graph a function. ");
+  menu.funcs[3]=graphFunc;
+  menu.bar[4]=new_item(" Load points ", " Load graph points from a file. ");
+  menu.funcs[4]=loadPoints;
+  menu.bar[5]=new_item(" Quadratic ", " Attempt a quadratic regression. ");
+  menu.funcs[5]=quadratic;
+  menu.bar[6]=new_item(" Linear ", " Attempt a linear regression. ");
+  menu.funcs[6]=linear;
+  menu.bar[7]=new_item(" Radians ", " Measure angles in radians. ");
+  menu.funcs[7]=angleRadians;
+  menu.bar[8]=new_item(" Degrees ", " Measure angles in degrees. ");
+  menu.funcs[8]=angleDegrees;
+  menu.bar[9]=new_item(" Custom angles ", 
+		       " Specify an angular measurement system. ");
+  menu.funcs[9]=angleCustom;
+  menu.bar[10]=new_item(" Exit ", " Exit the program. ");
+  menu.funcs[10]=quitProg;
+  menu.bar[11]=NULL;
+  menu.max=11;
+  menu.foo=new_menu(menu.bar);
+  set_menu_mark(menu.foo, "* ");
+
+  csc.a=A_NORMAL;
+  csc.b=A_REVERSE;
+  csc.c=A_BOLD;
+}
+
+void
+showMenu(void) {
+  int k=0;
+
+  post_menu(menu.foo);
+  while(k!=KEY_F(2)) {
+    k=getch();
+    switch(k) {
+    case KEY_UP:
+      if(--menu.s<0) menu.s=menu.max-1;
+      set_current_item(menu.foo, menu.bar[menu.s]);
+      break;
+    case KEY_DOWN:
+      if(++menu.s>=menu.max) menu.s=0;
+      set_current_item(menu.foo, menu.bar[menu.s]);
+      break;
+    case '\n':
+      menu.funcs[menu.s]();
+      k=KEY_F(2);
+      break;
+    }
+  }
+  unpost_menu(menu.foo);
+  drawScreen();
+}
+
+void
+expressionMode(void) {
+  unsigned int k=0, y=0, i, j;
+
+  history[y].text[0]=0;
+  history[y].x=0;
+  drawScreen();
+  for(;;) {
+    bkgdset(csc.c);
+    mvaddstr(LINES-1, 0, "> ");
+    bkgdset(csc.a);
+    addstr(history[y].text);
+    clrtoeol();
+    move(LINES-1, history[y].x+LMARGIN);
+    k=getch();
+    if(k>=' '&&k<127&&(j=strlen(history[y].text))<MAXINPUT-1) {
+      history[y].text[j+1]=0;
+      for(i=j;i>history[y].x;i--) history[y].text[i]=history[y].text[i-1];
+      history[y].text[history[y].x++]=k;
+    } else if((k==8||k==127||k==KEY_BACKSPACE)&&
+	      history[y].text[0]&&history[y].x) {
+      j=strlen(history[y].text);
+      history[y].x--;
+      for(i=history[y].x;i<j;) history[y].text[i]=history[y].text[++i];
+    } else if(k==4&&history[y].x<strlen(history[y].text)) {
+      j=strlen(history[y].text);
+      for(i=history[y].x;i<j;) history[y].text[i]=history[y].text[++i];
+    } else if(k==KEY_LEFT&&history[y].x) history[y].x--;
+    else if(k==KEY_RIGHT&&history[y].x<strlen(history[y].text)) history[y].x++;
+    else if(k==KEY_F(2)) showMenu();
+    else if(k==1) history[y].x=0;
+    else if(k==5) history[y].x=strlen(history[y].text);
+    else if(k=='\n'&&history[y].text[0]) {
+      foo.evaluate(history[y].text);
+      addMessage(history[y].text);
+      addMessage("");
+      snprintf(messages[0], MSGSIZE, " = %e, %f", foo.ans, foo.ans);
+      drawScreen();
+      strcpy(history[0].text, history[y].text);
+      history[0].x=history[y].x;
+      for(i=HISTORY-1;i;i--) {
+	history[i].x=history[i-1].x;
+	strcpy(history[i].text, history[i-1].text);
+      }
+      history[0].text[0]=0;
+      history[0].x=0;
+      y=0;
+    } else if(k==KEY_UP&&y<HISTORY-1) y++;
+    else if(k==KEY_DOWN&&y) y--;
+    else if(k==12) drawScreen();
+  }
+}
+
+int
+main(void) {
+  initscr();
+  cbreak();
+  noecho();
+  keypad(stdscr, TRUE);
+  init();
+  expressionMode();
+  endwin();
+}
diff -Nru dalc-0.1/dalexpr.C dalc-0.1.new/dalexpr.C
--- dalc-0.1/dalexpr.C	Thu Dec  9 08:17:05 1999
+++ dalc-0.1.new/dalexpr.C	Thu Jan  1 01:00:00 1970
@@ -1,358 +0,0 @@
-/*
- * Dalc
- * A powerful scientific DAL calculator
- * Copyright (C) 1999 Daniel Beer
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <ctype.h>
-#include <strings.h>
-#include <math.h>
-#include <time.h>
-#include "dalexpr.h"
-
-DALExpr::DALExpr(void) {
-  int i;
-
-  for(i=0;i<26;i++) vars[i]=0.0;
-  dtr=1.0;
-  ans=0.0;
-}
-
-DALExpr::~DALExpr(void) {
-}
-
-void
-DALExpr::evaluate(const char *e) {
-  int i, lt=-1;
-
-  srandom(time(NULL));
-  for(i=0;i<MAXTOKENS;i++) tokens[i][0]=0;
-
-  num=0;
-  tokens[0][0]=0;
-  for(i=0;e[i];i++) {
-    if(e[i]==',') {
-      advanceToken();
-      tokens[num][0]=')';
-      tokens[num][1]=0;
-      advanceToken();
-      tokens[num][0]='(';
-      tokens[num][1]=0;
-      advanceToken();
-    } else {
-      if(lt!=tType(e[i])) advanceToken();
-      if(tType(e[i])&&strlen(tokens[num])<TOKENSIZE-1) {
-	tokens[num][strlen(tokens[num])+1]=0;
-	tokens[num][strlen(tokens[num])]=e[i];
-      }
-      lt=tType(e[i]);
-      if(!(lt%2)) lt=-1;
-    }
-  }
-  if(tokens[num][0]) advanceToken();
-
-  breakDown(0);
-  ans=tokenVal[0];
-}
-
-double
-DALExpr::functionF(double x) {
-  switch(coeff.type) {
-  case F_QUADRATIC: return x*x*coeff.a+x*coeff.b+coeff.c;
-  case F_LINEAR: return x*coeff.a+coeff.b;
-  }
-  return 0.0;
-}
-
-double
-DALExpr::derivativeF(double x) {
-  switch(coeff.type) {
-  case F_QUADRATIC: return x*coeff.a*2.0+coeff.b;
-  case F_LINEAR: return coeff.a;
-  }
-  return 0.0;
-}
-
-double
-DALExpr::integralF(double x) {
-  switch(coeff.type) {
-  case F_QUADRATIC: return (x*x*x*coeff.a)/3.0+(x*x*coeff.b)/2.0+x*coeff.c;
-  case F_LINEAR: return (x*x*coeff.a)/2+x*coeff.b;
-  }
-  return 0.0;
-}
-
-double
-DALExpr::regressQuadratic(double *xpoints, double *ypoints, int numpoints) {
-  double a, b, c, aa, bb, cc, diff, bdiff=10000000.0, step;
-  int i;
-
-  coeff.type=F_QUADRATIC;
-  coeff.a=0.0;
-  coeff.b=0.0;
-  coeff.c=0.0;
-  for(step=1000.0;step>=0.0000001;step/=10) {
-    aa=coeff.a;
-    bb=coeff.b;
-    cc=coeff.c;
-    for(a=aa-step*10;a<=aa+step*10;a+=step)
-      for(b=bb-step*10;b<=bb+step*10;b+=step)
-	for(c=cc-step*10;c<=cc+step*10;c+=step) {
-	  diff=0.0;
-	  for(i=0;i<numpoints;i++)
-	    diff+=fabs(ypoints[i]-(a*xpoints[i]*xpoints[i]+b*xpoints[i]+c));
-	  if(diff<bdiff) {
-	    bdiff=diff;
-	    coeff.a=a;
-	    coeff.b=b;
-	    coeff.c=c;
-	  }
-	}
-  }
-  return bdiff;
-}
-
-double
-DALExpr::regressLinear(double *xpoints, double *ypoints, int numpoints) {
-  double a, b, aa, bb, diff, bdiff=10000000.0, step;
-  int i;
-
-  coeff.type=F_LINEAR;
-  coeff.a=0.0;
-  coeff.b=0.0;
-  for(step=1000.0;step>=0.0000001;step/=10) {
-    aa=coeff.a;
-    bb=coeff.b;
-    for(a=aa-step*10;a<=aa+step*10;a+=step)
-      for(b=bb-step*10;b<=bb+step*10;b+=step) {
-	diff=0.0;
-	for(i=0;i<numpoints;i++) diff+=fabs(ypoints[i]-(a*xpoints[i]+b));
-	if(diff<bdiff) {
-	  bdiff=diff;
-	  coeff.a=a;
-	  coeff.b=b;
-	}
-      }
-  }
-  return bdiff;
-}
-
-void
-DALExpr::breakDown(int from) {
-  int i;
-  double j;
-
-  for(i=from;i<num;i++)
-    if(!strcmp(tokens[i], "(")) {
-      breakDown(i+1);
-      remove(i);
-      remove(i+1);
-    }
-  for(i=from;i<num&&strcmp(tokens[i], ")");i++) {
-    if(!strcmp(tokens[i], "pi")) {
-      tokenVal[i]=M_PI;
-      tokens[i][0]='#';
-    } else if(!strcmp(tokens[i], "e")) {
-      tokenVal[i]=M_E;
-      tokens[i][0]='#';
-    } else if(!strcmp(tokens[i], "ans")) {
-      tokenVal[i]=ans;
-      tokens[i][0]='#';
-    } else if(!strcmp(tokens[i], "rand")) {
-      tokenVal[i]=random()%10000;
-      tokenVal[i]/=10000.0;
-      tokens[i][0]='#';
-    } else if(isupper(tokens[i][0])) {
-      tokenVal[i]=vars[tokens[i][0]-'A'];
-      tokens[i][0]='#';
-    }
-  }
-  for(i=from;i<num&&strcmp(tokens[i], ")");i++) {
-    if(!(strcmp(tokens[i], "^")&&strcmp(tokens[i], "**"))) {
-      tokenVal[i-1]=pow(tokenVal[i-1], tokenVal[i+1]);
-      remove(i);
-      remove(i);
-      i--;
-    } else if(!strcmp(tokens[i], "root")) {
-      tokenVal[i-1]=pow(tokenVal[i+1], 1.0/tokenVal[i-1]);
-      remove(i);
-      remove(i);
-      i--;
-    }
-  }
-  for(i=from;i<num&&strcmp(tokens[i], ")");i++) {
-    if(!strcmp(tokens[i], "sin")) {
-      tokenVal[i+1]=sin(tokenVal[i+1]*dtr);
-      remove(i);
-    } else if(!strcmp(tokens[i], "cos")) {
-      tokenVal[i+1]=cos(tokenVal[i+1]*dtr);
-      remove(i);
-    } else if(!strcmp(tokens[i], "tan")) {
-      tokenVal[i+1]=tan(tokenVal[i+1]*dtr);
-      remove(i);
-    } else if(!strcmp(tokens[i], "sec")) {
-      tokenVal[i+1]=1.0/cos(tokenVal[i+1]*dtr);
-      remove(i);
-    } else if(!strcmp(tokens[i], "asin")) {
-      tokenVal[i+1]=asin(tokenVal[i+1])/dtr;
-      remove(i);
-    } else if(!strcmp(tokens[i], "acos")) {
-      tokenVal[i+1]=acos(tokenVal[i+1])/dtr;
-      remove(i);
-    } else if(!strcmp(tokens[i], "atan")) {
-      tokenVal[i+1]=atan(tokenVal[i+1])/dtr;
-      remove(i);
-    } else if(!strcmp(tokens[i], "atanr")) {
-      tokenVal[i+1]=atan2(tokenVal[i+1], tokenVal[i+2])/dtr;
-      remove(i);
-      remove(i+1);
-    } else if(!strcmp(tokens[i], "asec")) {
-      tokenVal[i+1]=acos(1.0/tokenVal[i+1])/dtr;
-      remove(i);
-    } else if(!strcmp(tokens[i], "sinh")) {
-      tokenVal[i+1]=sinh(tokenVal[i+1])/dtr;
-      remove(i);
-    } else if(!strcmp(tokens[i], "cosh")) {
-      tokenVal[i+1]=cosh(tokenVal[i+1])/dtr;
-      remove(i);
-    } else if(!strcmp(tokens[i], "tanh")) {
-      tokenVal[i+1]=tanh(tokenVal[i+1])/dtr;
-      remove(i);
-    } else if(!strcmp(tokens[i], "hypot")) {
-      tokenVal[i+1]=hypot(tokenVal[i+1], tokenVal[i+2]);
-      remove(i);
-      remove(i+1);
-    } else if(!strcmp(tokens[i], "abs")) {
-      tokenVal[i+1]=fabs(tokenVal[i+1]);
-      remove(i);
-    } else if(!strcmp(tokens[i], "sqrt")) {
-      tokenVal[i+1]=sqrt(tokenVal[i+1]);
-      remove(i);
-    } else if(!strcmp(tokens[i], "log")) {
-      tokenVal[i+1]=log10(tokenVal[i+1]);
-      remove(i);
-    } else if(!strcmp(tokens[i], "f")) {
-      tokenVal[i+1]=functionF(tokenVal[i+1]);
-      remove(i);
-    } else if(!strcmp(tokens[i], "fi")) {
-      tokenVal[i+1]=integralF(tokenVal[i+1]);
-      remove(i);
-    } else if(!strcmp(tokens[i], "fd")) {
-      tokenVal[i+1]=derivativeF(tokenVal[i+1]);
-      remove(i);
-    } else if(!strcmp(tokens[i], "ln")) {
-      tokenVal[i+1]=log(tokenVal[i+1]);
-      remove(i);
-    } else if(!strcmp(tokens[i], "ceil")) {
-      tokenVal[i+1]=ceil(tokenVal[i+1]);
-      remove(i);
-    } else if(!strcmp(tokens[i], "floor")) {
-      tokenVal[i+1]=floor(tokenVal[i+1]);
-      remove(i);
-    } else if(!strcmp(tokens[i], "round")) {
-      tokenVal[i+1]=rint(tokenVal[i+1]);
-      remove(i);
-    } else if(!strcmp(tokens[i], "!")) {
-      j=tokenVal[i-1];
-      if(j<0) tokenVal[i-1]=asin(2.0);
-      else {
-	tokenVal[i-1]=1.0;
-	for(;j>0;j-=1.0) tokenVal[i-1]*=j;
-      }
-      remove(i);
-      i--;
-    } else if(!strcmp(tokens[i], "int")) {
-      if(tokenVal[i+1]>0.0) tokenVal[i+1]=floor(tokenVal[i+1]);
-      else tokenVal[i+1]=ceil(tokenVal[i+1]);
-      remove(i);
-    } else if(!strcmp(tokens[i], "frac")) {
-      if(tokenVal[i+1]>0.0) tokenVal[i+1]-=floor(tokenVal[i+1]);
-      else tokenVal[i+1]-=ceil(tokenVal[i+1]);
-      remove(i);
-    }
-  }
-  for(i=from;i<num&&strcmp(tokens[i], ")");i++) {
-    if(!strcmp(tokens[i], "*")) {
-      tokenVal[i-1]*=tokenVal[i+1];
-      remove(i);
-      remove(i);
-      i-=2;
-    } else if(!strcmp(tokens[i], "/")) {
-      tokenVal[i-1]/=tokenVal[i+1];
-      remove(i);
-      remove(i);
-      i-=2;
-    } else if(tokens[i][0]=='#'&&tokens[i+1][0]=='#'&&i+1<num) {
-      tokenVal[i]*=tokenVal[i+1];
-      remove(i+1);
-      i--;
-    }
-  }
-  for(i=from;i<num&&strcmp(tokens[i], ")");i++) {
-    if(!strcmp(tokens[i], "+")) {
-      tokenVal[i-1]+=tokenVal[i+1];
-      remove(i);
-      remove(i);
-      i--;
-    } else if(!strcmp(tokens[i], "-")) {
-      tokenVal[i-1]-=tokenVal[i+1];
-      remove(i);
-      remove(i);
-      i--;
-    }
-  }
-}
-
-double
-DALExpr::getValue(int which) {
-  if(which<0||which>=num) return 0.0;
-  return atof(tokens[which]);
-}
-
-void
-DALExpr::remove(int which) {
-  int i;
-
-  for(i=which+1;i<num;i++) {
-    strcpy(tokens[i-1], tokens[i]);
-    tokenVal[i-1]=tokenVal[i];
-  }
-  num--;
-}
-
-int
-DALExpr::tType(char k) {
-  if(k<=' ') return 0;
-  if(islower(k)) return 3;
-  if(isupper(k)) return 2;
-  if(isdigit(k)||k=='_'||k=='.') return 5;
-  if(k=='('||k==')') return 4;
-  return 1;
-}
-
-void
-DALExpr::advanceToken(void) {
-  if(!tokens[num][0]||num>=MAXTOKENS-1) return;
-  if(tType(tokens[num][0])==5) {
-    if(tokens[num][0]=='_') tokens[num][0]='-';
-    tokenVal[num]=atof(tokens[num]);
-    tokens[num][0]='#';
-  }
-  num++;
-}
diff -Nru dalc-0.1/dalexpr.cc dalc-0.1.new/dalexpr.cc
--- dalc-0.1/dalexpr.cc	Thu Jan  1 01:00:00 1970
+++ dalc-0.1.new/dalexpr.cc	Fri Nov 24 15:58:24 2000
@@ -0,0 +1,358 @@
+/*
+ * Dalc
+ * A powerful scientific DAL calculator
+ * Copyright (C) 1999 Daniel Beer
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <math.h>
+#include <time.h>
+#include "dalexpr.h"
+
+DALExpr::DALExpr(void) {
+  int i;
+
+  for(i=0;i<26;i++) vars[i]=0.0;
+  dtr=1.0;
+  ans=0.0;
+}
+
+DALExpr::~DALExpr(void) {
+}
+
+void
+DALExpr::evaluate(const char *e) {
+  int i, lt=-1;
+
+  srandom(time(NULL));
+  for(i=0;i<MAXTOKENS;i++) tokens[i][0]=0;
+
+  num=0;
+  tokens[0][0]=0;
+  for(i=0;e[i];i++) {
+    if(e[i]==',') {
+      advanceToken();
+      tokens[num][0]=')';
+      tokens[num][1]=0;
+      advanceToken();
+      tokens[num][0]='(';
+      tokens[num][1]=0;
+      advanceToken();
+    } else {
+      if(lt!=tType(e[i])) advanceToken();
+      if(tType(e[i])&&strlen(tokens[num])<TOKENSIZE-1) {
+	tokens[num][strlen(tokens[num])+1]=0;
+	tokens[num][strlen(tokens[num])]=e[i];
+      }
+      lt=tType(e[i]);
+      if(!(lt%2)) lt=-1;
+    }
+  }
+  if(tokens[num][0]) advanceToken();
+
+  breakDown(0);
+  ans=tokenVal[0];
+}
+
+double
+DALExpr::functionF(double x) {
+  switch(coeff.type) {
+  case F_QUADRATIC: return x*x*coeff.a+x*coeff.b+coeff.c;
+  case F_LINEAR: return x*coeff.a+coeff.b;
+  }
+  return 0.0;
+}
+
+double
+DALExpr::derivativeF(double x) {
+  switch(coeff.type) {
+  case F_QUADRATIC: return x*coeff.a*2.0+coeff.b;
+  case F_LINEAR: return coeff.a;
+  }
+  return 0.0;
+}
+
+double
+DALExpr::integralF(double x) {
+  switch(coeff.type) {
+  case F_QUADRATIC: return (x*x*x*coeff.a)/3.0+(x*x*coeff.b)/2.0+x*coeff.c;
+  case F_LINEAR: return (x*x*coeff.a)/2+x*coeff.b;
+  }
+  return 0.0;
+}
+
+double
+DALExpr::regressQuadratic(double *xpoints, double *ypoints, int numpoints) {
+  double a, b, c, aa, bb, cc, diff, bdiff=10000000.0, step;
+  int i;
+
+  coeff.type=F_QUADRATIC;
+  coeff.a=0.0;
+  coeff.b=0.0;
+  coeff.c=0.0;
+  for(step=1000.0;step>=0.0000001;step/=10) {
+    aa=coeff.a;
+    bb=coeff.b;
+    cc=coeff.c;
+    for(a=aa-step*10;a<=aa+step*10;a+=step)
+      for(b=bb-step*10;b<=bb+step*10;b+=step)
+	for(c=cc-step*10;c<=cc+step*10;c+=step) {
+	  diff=0.0;
+	  for(i=0;i<numpoints;i++)
+	    diff+=fabs(ypoints[i]-(a*xpoints[i]*xpoints[i]+b*xpoints[i]+c));
+	  if(diff<bdiff) {
+	    bdiff=diff;
+	    coeff.a=a;
+	    coeff.b=b;
+	    coeff.c=c;
+	  }
+	}
+  }
+  return bdiff;
+}
+
+double
+DALExpr::regressLinear(double *xpoints, double *ypoints, int numpoints) {
+  double a, b, aa, bb, diff, bdiff=10000000.0, step;
+  int i;
+
+  coeff.type=F_LINEAR;
+  coeff.a=0.0;
+  coeff.b=0.0;
+  for(step=1000.0;step>=0.0000001;step/=10) {
+    aa=coeff.a;
+    bb=coeff.b;
+    for(a=aa-step*10;a<=aa+step*10;a+=step)
+      for(b=bb-step*10;b<=bb+step*10;b+=step) {
+	diff=0.0;
+	for(i=0;i<numpoints;i++) diff+=fabs(ypoints[i]-(a*xpoints[i]+b));
+	if(diff<bdiff) {
+	  bdiff=diff;
+	  coeff.a=a;
+	  coeff.b=b;
+	}
+      }
+  }
+  return bdiff;
+}
+
+void
+DALExpr::breakDown(int from) {
+  int i;
+  double j;
+
+  for(i=from;i<num;i++)
+    if(!strcmp(tokens[i], "(")) {
+      breakDown(i+1);
+      remove(i);
+      remove(i+1);
+    }
+  for(i=from;i<num&&strcmp(tokens[i], ")");i++) {
+    if(!strcmp(tokens[i], "pi")) {
+      tokenVal[i]=M_PI;
+      tokens[i][0]='#';
+    } else if(!strcmp(tokens[i], "e")) {
+      tokenVal[i]=M_E;
+      tokens[i][0]='#';
+    } else if(!strcmp(tokens[i], "ans")) {
+      tokenVal[i]=ans;
+      tokens[i][0]='#';
+    } else if(!strcmp(tokens[i], "rand")) {
+      tokenVal[i]=random()%10000;
+      tokenVal[i]/=10000.0;
+      tokens[i][0]='#';
+    } else if(isupper(tokens[i][0])) {
+      tokenVal[i]=vars[tokens[i][0]-'A'];
+      tokens[i][0]='#';
+    }
+  }
+  for(i=from;i<num&&strcmp(tokens[i], ")");i++) {
+    if(!(strcmp(tokens[i], "^")&&strcmp(tokens[i], "**"))) {
+      tokenVal[i-1]=pow(tokenVal[i-1], tokenVal[i+1]);
+      remove(i);
+      remove(i);
+      i--;
+    } else if(!strcmp(tokens[i], "root")) {
+      tokenVal[i-1]=pow(tokenVal[i+1], 1.0/tokenVal[i-1]);
+      remove(i);
+      remove(i);
+      i--;
+    }
+  }
+  for(i=from;i<num&&strcmp(tokens[i], ")");i++) {
+    if(!strcmp(tokens[i], "sin")) {
+      tokenVal[i+1]=sin(tokenVal[i+1]*dtr);
+      remove(i);
+    } else if(!strcmp(tokens[i], "cos")) {
+      tokenVal[i+1]=cos(tokenVal[i+1]*dtr);
+      remove(i);
+    } else if(!strcmp(tokens[i], "tan")) {
+      tokenVal[i+1]=tan(tokenVal[i+1]*dtr);
+      remove(i);
+    } else if(!strcmp(tokens[i], "sec")) {
+      tokenVal[i+1]=1.0/cos(tokenVal[i+1]*dtr);
+      remove(i);
+    } else if(!strcmp(tokens[i], "asin")) {
+      tokenVal[i+1]=asin(tokenVal[i+1])/dtr;
+      remove(i);
+    } else if(!strcmp(tokens[i], "acos")) {
+      tokenVal[i+1]=acos(tokenVal[i+1])/dtr;
+      remove(i);
+    } else if(!strcmp(tokens[i], "atan")) {
+      tokenVal[i+1]=atan(tokenVal[i+1])/dtr;
+      remove(i);
+    } else if(!strcmp(tokens[i], "atanr")) {
+      tokenVal[i+1]=atan2(tokenVal[i+1], tokenVal[i+2])/dtr;
+      remove(i);
+      remove(i+1);
+    } else if(!strcmp(tokens[i], "asec")) {
+      tokenVal[i+1]=acos(1.0/tokenVal[i+1])/dtr;
+      remove(i);
+    } else if(!strcmp(tokens[i], "sinh")) {
+      tokenVal[i+1]=sinh(tokenVal[i+1])/dtr;
+      remove(i);
+    } else if(!strcmp(tokens[i], "cosh")) {
+      tokenVal[i+1]=cosh(tokenVal[i+1])/dtr;
+      remove(i);
+    } else if(!strcmp(tokens[i], "tanh")) {
+      tokenVal[i+1]=tanh(tokenVal[i+1])/dtr;
+      remove(i);
+    } else if(!strcmp(tokens[i], "hypot")) {
+      tokenVal[i+1]=hypot(tokenVal[i+1], tokenVal[i+2]);
+      remove(i);
+      remove(i+1);
+    } else if(!strcmp(tokens[i], "abs")) {
+      tokenVal[i+1]=fabs(tokenVal[i+1]);
+      remove(i);
+    } else if(!strcmp(tokens[i], "sqrt")) {
+      tokenVal[i+1]=sqrt(tokenVal[i+1]);
+      remove(i);
+    } else if(!strcmp(tokens[i], "log")) {
+      tokenVal[i+1]=log10(tokenVal[i+1]);
+      remove(i);
+    } else if(!strcmp(tokens[i], "f")) {
+      tokenVal[i+1]=functionF(tokenVal[i+1]);
+      remove(i);
+    } else if(!strcmp(tokens[i], "fi")) {
+      tokenVal[i+1]=integralF(tokenVal[i+1]);
+      remove(i);
+    } else if(!strcmp(tokens[i], "fd")) {
+      tokenVal[i+1]=derivativeF(tokenVal[i+1]);
+      remove(i);
+    } else if(!strcmp(tokens[i], "ln")) {
+      tokenVal[i+1]=log(tokenVal[i+1]);
+      remove(i);
+    } else if(!strcmp(tokens[i], "ceil")) {
+      tokenVal[i+1]=ceil(tokenVal[i+1]);
+      remove(i);
+    } else if(!strcmp(tokens[i], "floor")) {
+      tokenVal[i+1]=floor(tokenVal[i+1]);
+      remove(i);
+    } else if(!strcmp(tokens[i], "round")) {
+      tokenVal[i+1]=rint(tokenVal[i+1]);
+      remove(i);
+    } else if(!strcmp(tokens[i], "!")) {
+      j=tokenVal[i-1];
+      if(j<0) tokenVal[i-1]=asin(2.0);
+      else {
+	tokenVal[i-1]=1.0;
+	for(;j>0;j-=1.0) tokenVal[i-1]*=j;
+      }
+      remove(i);
+      i--;
+    } else if(!strcmp(tokens[i], "int")) {
+      if(tokenVal[i+1]>0.0) tokenVal[i+1]=floor(tokenVal[i+1]);
+      else tokenVal[i+1]=ceil(tokenVal[i+1]);
+      remove(i);
+    } else if(!strcmp(tokens[i], "frac")) {
+      if(tokenVal[i+1]>0.0) tokenVal[i+1]-=floor(tokenVal[i+1]);
+      else tokenVal[i+1]-=ceil(tokenVal[i+1]);
+      remove(i);
+    }
+  }
+  for(i=from;i<num&&strcmp(tokens[i], ")");i++) {
+    if(!strcmp(tokens[i], "*")) {
+      tokenVal[i-1]*=tokenVal[i+1];
+      remove(i);
+      remove(i);
+      i-=2;
+    } else if(!strcmp(tokens[i], "/")) {
+      tokenVal[i-1]/=tokenVal[i+1];
+      remove(i);
+      remove(i);
+      i-=2;
+    } else if(tokens[i][0]=='#'&&tokens[i+1][0]=='#'&&i+1<num) {
+      tokenVal[i]*=tokenVal[i+1];
+      remove(i+1);
+      i--;
+    }
+  }
+  for(i=from;i<num&&strcmp(tokens[i], ")");i++) {
+    if(!strcmp(tokens[i], "+")) {
+      tokenVal[i-1]+=tokenVal[i+1];
+      remove(i);
+      remove(i);
+      i--;
+    } else if(!strcmp(tokens[i], "-")) {
+      tokenVal[i-1]-=tokenVal[i+1];
+      remove(i);
+      remove(i);
+      i--;
+    }
+  }
+}
+
+double
+DALExpr::getValue(int which) {
+  if(which<0||which>=num) return 0.0;
+  return atof(tokens[which]);
+}
+
+void
+DALExpr::remove(int which) {
+  int i;
+
+  for(i=which+1;i<num;i++) {
+    strcpy(tokens[i-1], tokens[i]);
+    tokenVal[i-1]=tokenVal[i];
+  }
+  num--;
+}
+
+int
+DALExpr::tType(char k) {
+  if(k<=' ') return 0;
+  if(islower(k)) return 3;
+  if(isupper(k)) return 2;
+  if(isdigit(k)||k=='_'||k=='.') return 5;
+  if(k=='('||k==')') return 4;
+  return 1;
+}
+
+void
+DALExpr::advanceToken(void) {
+  if(!tokens[num][0]||num>=MAXTOKENS-1) return;
+  if(tType(tokens[num][0])==5) {
+    if(tokens[num][0]=='_') tokens[num][0]='-';
+    tokenVal[num]=atof(tokens[num]);
+    tokens[num][0]='#';
+  }
+  num++;
+}
